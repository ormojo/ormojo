export typeSymbol = Symbol("type")

export class Type:
  constructor(name) ->
    this[typeSymbol] = this
    this.name = name

  construct() ->
    throw new Error("cannot construct abstract type")

  // eslint-disable-next-line no-unused-vars
  validate(x) -> false

  isType(x) -> x === this

export class EntityType extends Type:
  constructor(name, entityConstructor) ->
    super(name)
    this.entityConstructor = entityConstructor

  construct() ->
    new (this.entityConstructor)()

  validate(x) ->
    x~looseEq(null) or (x instanceof this.entityConstructor)

  isKindOf(T) ->
    (T instanceof EntityType)
    and (
      T.entityConstructor == this.entityConstructor or
      this.entityConstructor.prototype instanceof T.entityConstructor
    )

///////////////////// Primitive types
export class PrimitiveType extends Type:
  constructor(name) ->
    super(name)

  construct() ->
    throw new Error("cannot construct primitive type")

  isKindOf(T) -> T === this

any = new PrimitiveType("any")
any.validate = -> true

nil = new PrimitiveType("nil")
nil.validate = (x) -> x~looseEq(null)

number = new PrimitiveType("number")
number.validate = (x) -> x~looseEq(null) or typeof x == "number"

string = new PrimitiveType("string")
string.validate = (x) -> x~looseEq(null) or typeof x == "string"

boolean = new PrimitiveType("boolean")
boolean.validate = (x) -> x~looseEq(null) or typeof x == "boolean"

// TODO: improve this
integer = new PrimitiveType("integer")
integer.validate = (x) -> x~looseEq(null) or typeof x == "number"

object = new PrimitiveType("object")
object.validate = (x) ->
  x~looseEq(null)
  or (
    typeof x == "object" and
    (not Array.isArray(x))
  )

array = new PrimitiveType("array")
array.validate = (x) ->
  x~looseEq(null)
  or (
    typeof x != "function" and
    x.length >= 0
  )

// anything that could be serialized as json, opaque
// TODO: improve this, should recurse to see if we could jsonify it
json = new PrimitiveType("json")
json.validate = (x) ->
  if x~looseEq(null): return true
  t = typeof x
  (
    t == "number"
    or t == "string"
    or t == "boolean"
    or t == "object"
    or Array.isArray(x)
  )

export {
  nil
  any
  string
  number
  integer
  object
  array
  boolean
  json
}

/////////////// Type introspection helpers
export __setType(ent, T) ->
  ent[typeSymbol] = T

export isEntityConstructor(x): boolean ->
  typeof x == "function" and (x[typeSymbol] instanceof EntityType)

export typeFrom(x) ->
  x[typeSymbol]

export isType(x): boolean ->
  t = typeof x
  (t == "function" or t == "object") and (x[typeSymbol] instanceof Type)

export typeName(type): string ->
  type.name or '(anonymous type)'

export isPrimitiveType(type): boolean ->
  type[typeSymbol] instanceof PrimitiveType

export isa(ent, ty): boolean ->
  if not ty: return false
  now ty = ty[typeSymbol]
  ty.validate(ent)

export typeOf(ent) ->
  if ent~looseEq(null): return nil

  // prims
  t = typeof ent
  if t == "number": return number
  elif t == "string": return string
  elif t == "boolean": return boolean

  if Array.isArray(ent): return array
  constr = ent.constructor
  if constr and constr[typeSymbol]:
    constr
  else:
    object

//////////////// Required types
export required(T) ->
  now T = T[typeSymbol]
  if T.__required:
    throw new Error("Cannot apply required() twice.")

  RequiredT = new (T.constructor)(`required(${T~typeName!})`, T.entityConstructor)
  RequiredT.__underlyingType = T
  RequiredT.__required = true
  RequiredT.validate = (x) ->
    x~looseNotEq(null) and T.validate(x)
  RequiredT.isType = (otherT) ->
    otherT.__required and otherT.__underlyingType.isType(this.__underlyingType)

  RequiredT
