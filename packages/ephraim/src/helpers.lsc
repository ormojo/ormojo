'use @oigroup/lightscript with existential'

import { any, isPrimitiveType, isEntityConstructor } from './types'

export declaredFields(x) ->
  if x~isEntityConstructor!: now x = x.prototype
  x?.__fields or {}

export hasDeclaredField(x, fieldName): boolean ->
  if x~isEntityConstructor!: now x = x.prototype
  x?.__fields?[fieldName]?

export flexFieldKeys(x) ->
  if x~isEntityConstructor!:
    throw new Error("flexFieldKeys is illegal on entity constructors")
  [...for key k in x: if k.charCodeAt(0) != 95: [k] ]

export fieldKeys(x) ->
  if x~isEntityConstructor!:
    [...for key k in x.prototype.__fields: [k] ]
  else:
    [
      ...for key k in x.__fields: [k]
      ...for key k in x: if k.charCodeAt(0) != 95: [k]
    ]

export forEachField(x, f): void ->
  if not x: return

  for key k, val spec in (x.__fields or {}):
    f(k, x[k], spec)

  for key k in x: if k.charCodeAt(0) != 95: f(k, x[k])

export toPlainObject(x, strict) ->
  if x.__toPlainObject: return x.__toPlainObject(strict)

  result = {}
  x~forEachField! (k, v, spec): void ->
    if spec:
      if spec.type~isPrimitiveType!:
        result[k] = v
      elif spec.type == any:
        if not strict:
          result[k] = v
        else:
          throw new Error(`Cannot convert key '${k}' of indeterminate type 'any' to a plain object`)
      else:
        result[k] = v~toPlainObject(strict)
    elif not strict: // no flex fields when strict
      result[k] = v

  result

export delta(ent) ->
  if ent.__isDelta:
    ent.__delta or {}
  else:
    throw new Error(`delta() called on a non-delta entity`)

export deltaKeys(ent) ->
  if ent.__isDelta:
    if ent.__delta: Object.keys(ent.__delta) else: []
  else:
    throw new Error(`deltaKeys() called on a non-delta entity`)

export isDelta(ent): boolean -> Boolean(ent.__isDelta)

export trackDelta(ent): void ->
  ent.__isDelta = true
  ent~_statusChanged()

export flushDelta(ent): void ->
  if not ent.__isDelta:
    throw new Error(`flushDelta() called on a non-delta entity`)

  // For any key that's a primitive type, update data
  data = ent.__data
  for key k, val v in ent.__delta:
    type = ent.__fields[k].type
    if type~isPrimitiveType!: data[k] = v

  ent.__delta = undefined
  ent~_statusChanged()

export hasDelta(ent): boolean -> ent.__delta?

// XXX
// eslint-disable-next-line no-unused-vars
export _statusChanged(ent) -> return
