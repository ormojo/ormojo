'use @oigroup/lightscript'

// TODO: compile out setter typechecks on prod builds

import { any, isType, isPrimitiveType, typeName, EntityType, typeSymbol, typeFrom, typeOf } from './types'

{ assign } = Object

initializeField(ent, key, spec): void ->
  if spec.type~isPrimitiveType!:
    if spec.defaulter: ent[key] = spec.defaulter.call(ent)
  else:
    if spec.defaulter:
      defResult = spec.defaulter.call(ent)
      if typeof defResult == "function":
        ent[key] = spec.type.__factory()
        defResult.call(ent, ent[key])
      else:
        ent[key] = null

checkSpecValidity(spec): void ->
  if typeof spec != "object":
    throw new Error("Invalid use of @field decorator, did you forget ()?")

  spec.type = typeFrom(spec.type)

checkFieldDefinitionValidity(proto, key, spec) ->
  className = proto.constructor?.name or "(anonymous class)"
  type = spec.type

  if proto.__fields?[key]:
    throw new Error(`Field '${key}' of class '${className}' is already defined`)

  if not type~isType!:
    throw new Error(`Field '${key}' of class '${className}' has invalid type`)

  if type~isPrimitiveType! and type.__required and not spec.defaulter:
    throw new Error(`Field '${key}' of class '${className}' is required, but no default value was provided.`)

maybeInheritFields(proto): void ->
  // If I don't have my own fields...
  if not proto.hasOwnProperty('__fields'):
    // Create, inheriting from parent if possible
    proto.__fields = {}~assign(proto.__fields)

export entity(opts) ->
  if typeof opts == "function":
    throw new Error("Invalid use of @entity decorator, did you forget ()?")

  (constructor) ->
    proto = constructor.prototype

    newConstructor = (skipInit) ->
      this.__data = {}
      if not skipInit:
        for key k, val spec in this.__fields:
          this~initializeField(k, spec)

      return this

    type = new EntityType(constructor.name, newConstructor)

    newConstructor.prototype = proto
    proto.constructor = newConstructor
    newConstructor[typeSymbol] = type

    Object.defineProperty(newConstructor, "name", { value: constructor.name })
    newConstructor

typeCheckAndThrow(key, val, type) ->
  if not type.validate(val):
    throw new Error(`Value assigned to '${key}' must be of type '${typeName(type)}', was of type '${typeOf(val).name}'`)

makePrimitiveValueSetter(key, type) ->
  // TODO: special handling for id
  (val): void ->
    if type != any: typeCheckAndThrow(key, val, type)
    if this.__isDelta:
      let delta = this.__delta
      if not delta:
        now delta = {}
        this.__delta = delta
      delta[key] = val
    else:
      this.__data[key] = val

makePrimitiveValueGetter(key) ->
  () ->
    if this.__isDelta:
      r = this.__delta?[key]
      if r == undefined: this.__data[key] else: r
    else:
      this.__data[key]

makeComplexValueSetter(key, type) ->
  (val): void ->
    curVal = this[key]
    // noop
    if val == curVal: return
    // Mandatory typechecks
    typeCheckAndThrow(key, val, type)
    this.__data[key] = val
    if curVal: curVal.__entityParent = undefined
    if not val: return
    // Set __entityParent
    val.__entityParent = this
    // Proper delta handling
    if this.__isDelta:
      let delta = this.__delta
      if not delta:
        now delta = {}
        this.__delta = delta
      delta[key] = true

makeComplexValueGetter(key) ->
  () ->
    this.__data[key]

export field(spec) ->
  if not spec: now spec = { type: any }
  if spec~isType!:
    now spec = { type: spec }
  checkSpecValidity(spec)
  type = spec.type

  (proto, key, descriptor) ->
    spec.key = key
    proto~maybeInheritFields!
    if not spec.defaulter: spec.defaulter = descriptor.initializer
    checkFieldDefinitionValidity(proto, key, spec)

    // Prevent constructor from calling initializer
    delete descriptor.initializer
    delete descriptor.value
    delete descriptor.writable
    descriptor.configurable = true
    descriptor.enumerable = true

    // Getter and setter
    if type~isPrimitiveType!:
      descriptor.set = makePrimitiveValueSetter(key, type)
      descriptor.get = makePrimitiveValueGetter(key)
    else:
      descriptor.set = makeComplexValueSetter(key, type)
      descriptor.get = makeComplexValueGetter(key)

    proto.__fields[key] = spec
    descriptor
