'use @oigroup/lightscript with noEnforcedSubscriptIndentation'

import { Backend, normalizeLoggerObject, setBackend } from '@ormojo/ormojo'
import { typeOf, typeFrom, createMemoryDelta as create, assignPlainObject, underlyingTypeOfType } from '@ormojo/ephraim'

import { MySQLTables } from './metadata/tables'
import { MySQLMigration } from './migration'
import { MySQLQuery } from './query'
import { finalize } from './util'
import { MySQLConnectionManager } from './connection'
import { MySQLSink } from './sink'
import { MySQLSource } from './source'

export class MySQLBackend extends Backend:
  constructor(mysql2, opts) ->
    super()
    this.log = normalizeLoggerObject(opts?.log)
    // Initialize SQL backend api, including connection pool if enabled
    this.connectionManager = if opts?.connectionManager:
      opts.connectionManager
    else:
      mgr = new MySQLConnectionManager(mysql2)
      mgr.defaultSetup(opts)
      mgr
    // Record target database
    this.database = opts.database
    if not this.database:
      throw new Error("MySQLBackend: opts.database is required")
    // The table registry contains information mapping ephraim entity types
    // onto tables.
    this._clearInternalTableStructure!
    // Sink/source
    this.sink = new MySQLSink({backend: this, log: this.log})
    this.source = new MySQLSource({backend: this, log: this.log})

  _clearInternalTableStructure(): void ->
    this.tables = new MySQLTables(this, this.database)
    this.typeMap = new Map()

  bind(T, opts): void ->
    now T = typeFrom(T)
    if not T: throw new Error(`MySQLBackend.bind: a type is required`)
    if this.typeMap.has(T):
      throw new Error(`MySQLBackend.bind: duplicate registration of type '${T.name}'`)
    now opts = opts or {}
    opts.table = opts.table or T.name
    if this.tables.has(opts.table):
      throw new Error(`MySQLBackend.bind: multiple types assigned to table '${opts.table}'`)
    // Create table representation
    tableRepresentation = this.tables.getOrCreateTableByName(opts.table)
    this.typeMap.set(T, tableRepresentation)
    tableRepresentation.deriveFromType(T, opts)

  // Shutdown backend, closing all pooled connections
  shutdown(): Promise<any> ->
    { log } = this
    this.connectionManager.shutdown().then(-> log.info("MySQLBackend: shutdown complete"))

  // Run a single raw query
  rawQuery(str, params, conn) ->
    if conn:
      if params:
        this.log.trace(`SQL: ${str}`, params)
      else:
        this.log.trace(`SQL: ${str}`)
      conn.query(str, params)
      .catch! (err) =>
        this.log.error('Error while executing SQL: "', str, '" with params ', params, ': ', err)
        throw err
    else:
      // Lease a connection for the duration of the query only.
      mgr = this.connectionManager
      let theConn = null
      mgr.openConnection()
      .then! (conn) =>
        now theConn = conn
        if params:
          this.log.trace(`SQL: ${str}`, params)
        else:
          this.log.trace(`SQL: ${str}`)
        conn.query(str, params)
      ~finalize! ->
        if theConn: mgr.closeConnection(theConn)
      .catch! (err) =>
        this.log.error('Error while executing SQL: "', str, '" with params ', params, ': ', err)
        throw err

  _getTableForType(T) ->
    table = this.typeMap.get(typeFrom(T))
    if not table:
      throw new Error(`MySQLBackend: Type '${T.name}' is not bound to this backend.`)
    table

  _getTableForInstance(inst) ->
    this._getTableForType(underlyingTypeOfType(typeOf(inst)))

  createMigration(): MySQLMigration ->
    new MySQLMigration(this)

  createQuery(): MySQLQuery ->
    new MySQLQuery(this)

  create(type, data, opts) ->
    instance = create(type)
    instance~setBackend(this)
    instance._isNewRecord = true
    if data~looseNotEq(null):
      instance~assignPlainObject(data)
      if not opts?.noPersist:
        this.save(instance, opts)
      else:
        instance
    else:
      instance

  save(instance, opts) ->
    { sink } = this
    if Array.isArray(instance):
      sink.crupsert(instance, opts).then! -> instance
    else:
      sink.crupsert([instance], opts).then! -> instance

  destroy(instance, opts) ->
    { sink } = this
    sink.delete([instance], opts).then! (rst) ->
      if rst?.results[0]: instance._wasDeleted = true
      instance

  // eslint-disable-next-line no-unused-vars
  destroyById(T, id, opts) ->
    now T = typeFrom(T)
    this.sink.deleteById(this.typeMap.get(T), id)

  destroyByQuery(q) ->
    this.sink.deleteByQuery(q)

  find(query) ->
    this.source.read(query)
