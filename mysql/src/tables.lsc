'use @oigroup/lightscript with noEnforcedSubscriptIndentation'

import { sqlTypeMap } from './sqlTypeMap'
import { declaredFieldKeys, declaredFields } from '@ormojo/ephraim'
import { quoteIdentifier, escapeValue, array_move } from './util'

_createColumn(table, colName, fieldKey, colType) ->
  column = new MySQLColumn(table.backend, table.database, table.name, colName)
  table.addColumn(column)
  column.ephraimField = fieldKey
  column.nullable = true
  column.type = colType
  column

export class MySQLColumn:
  constructor(backend, database, tableName, name) ->
    this.backend = backend
    this.database = database
    this.tableName = tableName
    this.name = name
    this.quotedName = quoteIdentifier(name)
    this.fqcn = `${quoteIdentifier(tableName)}.${quoteIdentifier(name)}`

  _fromInformationSchemaRow(row): void ->
    this.nullable = if row.is_nullable == 'YES': true else: false
    this.ordinalPosition = row.ordinal_position
    this.keyType = row.column_key
    this.type = row.column_type
    this.charset = row.character_set_name
    this.collation = row.collation_name
    this.default = row.column_default
    this.autoIncrement = /auto_increment/.test(row.extra)

  _toDDL(): string ->
    nullability = if this.nullable: 'NULL' else: 'NOT NULL'
    def = if this.default: `DEFAULT ${escapeValue(this.default)}` else: ''
    incr = if this.autoIncrement: 'AUTO_INCREMENT' else: ''
    key = match this.keyType:
      | 'PRI': 'PRIMARY KEY'
      | 'UNI': 'UNIQUE'
      | else: ''
    `${quoteIdentifier(this.name)} ${this.type} ${nullability} ${def} ${incr} ${key}`

export class MySQLIndex:
  constructor(table) ->
    this.backend = table.backend
    this.table = table
    this.columnNames = []

  getName(): string ->
    if this.name:
      this.name
    else:
      this.name = this._computeName!
      this.name

  // Generate canonical index name
  _computeName(): string ->
    if this.unique:
      `${this.table.name}_${this.columnNames.join('_')}'_unique'`
    else:
      `${this.table.name}_${this.columnNames.join('_')}`

  _toDDL(): string ->
    if this.columnNames.length == 0: return ''
    uniqueClause = if this.unique: 'UNIQUE' else: ''
    nameClause = quoteIdentifier(this.getName!)
    columnClause = this.columnNames.map(x -> quoteIdentifier(x)).join(',')
    `${uniqueClause} INDEX ${nameClause} (${columnClause})`

export class MySQLForeignKey extends MySQLIndex:
  constructor(table) ->
    super(table)
    this.referencedColumnNames = []
    this.onDelete = "CASCADE"
    this.onUpdate = "CASCADE"

  setSingleColumn(columnName, foreignTableName, foreignColumnName) ->
    this.columnNames = [columnName]
    this.referencedTableName = foreignTableName
    this.referencedColumnNames = [foreignColumnName]
    this

  _computeName(): string ->
    `fk_${this.table.name}_${this.referencedTableName}_${this.columnNames.join('_')}_${this.referencedColumnNames.join('_')}`

  _toDDL(): string ->
    `FOREIGN KEY ${quoteIdentifier(this.getName!)} (${quoteIdentifier(this.columnNames[0])}) REFERENCES ${quoteIdentifier(this.referencedTableName)} (${quoteIdentifier(this.referencedColumnNames[0])}) ON DELETE ${this.onDelete} ON UPDATE ${this.onUpdate}`

  _fromReferentialConstraintsColumn(col): void ->
    this.name = col.constraint_name
    this.onDelete = col.delete_rule
    this.onUpdate = col.update_rule
    this.referencedTableName = col.referenced_table_name

  _getColumnsFromInformationSchema(): Promise<void> ->
    this.backend.rawQuery('SELECT column_name, referenced_column_name FROM information_schema.key_column_usage WHERE table_name=? AND table_schema=? AND constraint_name=? ORDER BY ordinal_position ASC', [this.table.name, this.table.database, this.name])
    .then! (rst): void =>
      for elem colInfo in rst[0] or []:
        this.columnNames.push(colInfo.column_name)
        this.referencedColumnNames.push(colInfo.referenced_column_name)

// Represents a MySQL table
export class MySQLTable:
  constructor(backend, database, name) ->
    this.backend = backend
    this.database = database
    this.name = name
    this.quotedName = quoteIdentifier(name)
    this.columns = {}
    this.ordinalColumns = []
    this.indices = {}

  _dropTable(): Promise<any> ->
    this.backend.rawQuery(`DROP TABLE ${this.quotedName};`)

  _createColumnForInformationSchemaRow(row): void ->
    col = new MySQLColumn(this.backend, this.database, this.name, row.column_name)
    col._fromInformationSchemaRow(row)
    this.columns[row.column_name] = col
    this.ordinalColumns[row.ordinal_position - 1] = col

  _getForeignKeys(): Promise<void> ->
    this.backend.rawQuery('SELECT constraint_name, referenced_table_name, delete_rule, update_rule FROM information_schema.referential_constraints WHERE constraint_schema=? AND table_name=?', [this.database, this.name])
    .then! (rst) =>
      promises = [...for elem fkDef in rst[0] or []:
        fk = new MySQLForeignKey(this)
        fk._fromReferentialConstraintsColumn(fkDef)
        this.addIndex(fk)
        [fk._getColumnsFromInformationSchema!]
      ]
      Promise.all(promises)

  _getDomesticKeys(): Promise<void> ->
    this.backend.rawQuery('SELECT index_name, column_name, seq_in_index, non_unique FROM information_schema.statistics WHERE table_schema=? AND table_name=? AND index_name<>\'PRIMARY\'', [this.database, this.name])
    .then! (rst): void =>
      let currentIndex = null
      for elem ixDef in rst[0] or []:
        if (not this.indices[ixDef.index_name]) and ixDef.seq_in_index == 1:
          now currentIndex = new MySQLIndex(this)
          currentIndex.name = ixDef.index_name
          this.addIndex(currentIndex)
          if ixDef.non_unique == 0: ixDef.unique = true

        if currentIndex and (currentIndex.name == ixDef.index_name):
          currentIndex.columnNames.push(ixDef.column_name)

  // Get columns from MySQL
  _getTableMetadata(): Promise<any> ->
    // Clear existing
    this.columns = {}
    this.ordinalColumns = []
    this.backend.rawQuery('SELECT table_schema, table_name, column_name, ordinal_position, column_default, is_nullable, data_type, character_set_name, collation_name, column_type, column_key, extra FROM information_schema.columns WHERE table_name=? AND table_schema=?;', [this.name, this.database])
    .then! (rst) =>
      for elem row in rst[0] or []: this._createColumnForInformationSchemaRow(row)
      this._getForeignKeys!
    .then! =>
      this._getDomesticKeys!


  // Generate CREATE TABLE DDL
  _toCreateDDL(unchecked): string ->
    createDefs = [
      ...for elem col in this.ordinalColumns: [col._toDDL!]
      ...for val idx in this.indices: [idx._toDDL!]
    ].join(',')
    `CREATE TABLE ${if unchecked: '' else: 'IF NOT EXISTS'} ${quoteIdentifier(this.name)} (${createDefs})`

  // Insert a column at the ordinally-last position in this table
  addColumn(col: MySQLColumn): void ->
    if this.columns[col.name]:
      throw new Error(`Duplicate column name '${col.name}'`)
    this.ordinalColumns.push(col)
    this.columns[col.name] = col

  // Add an index
  addIndex(idx: MySQLIndex): void ->
    this.indices[idx.getName!] = idx

  // Derive a table from an Ormojo type plus an options object.
  // opts = {
  //    table: string -- name of table, defaults to T.name
  //    fields: {
  //      [ephraimFieldName]: {
  //        column: string -- name of SQL table column for this field, defaults to field name
  //        ignore: boolean -- if true, field will not be mapped to SQL
  //        autoIncrement: boolean -- apply MySQL AUTOINCREMENT
  //        default: string -- MySQL default clause
  //      }
  //      ...
  //    }
  //    indices: [
  //      { columnNames: [col1, ...], unique: boolean }
  //    ]
  // }
  deriveFromType(T, opts): void -> {
    this.derivedFromType = T
    fieldOpts = opts?.fields or {}
    fieldSpecs = T~declaredFields()
    fieldKeyList = T~declaredFieldKeys().slice()

    // Information used while serializing and deserializing
    columnSequence = [] // SELECT sequence
    readPattern = [['create', T]] // Pattern for deserializing this type of object
    columnForField = Object.create(null) // Field-name-to-column map
    this.columnSequence = columnSequence
    this.readPattern = readPattern
    this.columnForField = columnForField

    // Make id the ordinally-first column if it exists
    if T~declaredFields().id:
      array_move(fieldKeyList, fieldKeyList.indexOf('id'), 0)

    // Enumerate keys and create columns
    for elem fieldKey in fieldKeyList:
      thisFieldSpec = fieldSpecs[fieldKey]
      thisFieldOpts = fieldOpts[fieldKey] or {}
      // Allow fields to be ignored
      if thisFieldOpts.ignore: continue
      // Allow fields to be renamed
      colName = thisFieldOpts.column or fieldKey
      // Only create columns if we can determine the data type
      colType = thisFieldOpts.type or sqlTypeMap(thisFieldSpec.type)
      if not colType: continue
      // Create the column representation
      column = _createColumn(this, colName, fieldKey, colType)
      // Establish column demographics
      if fieldKey == 'id' or thisFieldOpts.primaryKey:
        if this.pkColumnFqcn:
          throw new Error(`MySQLTable: multiple primary keys not allowed for type '${T.name}'`)
        if thisFieldOpts.primaryKey and fieldKey != 'id' and fieldSpecs['id']:
          throw new Error(`MySQLTable: 'id' column must be primary key for type '${T.name}`)
        this.pkColumnFqcn = column.fqcn
        this.pkFieldKey = fieldKey
        if fieldKey == 'id': this.idColumnFqcn = column.fqcn
        column.nullable = false
        column.keyType = 'PRI'
        if thisFieldOpts.autoIncrement:
          column.autoIncrement = true
          // Flag for auto-increment ID; upon insertion we will automatically
          // read the ID from the database
          this.hasAutoIncrementId = true
      if thisFieldOpts.default != undefined:
        column.default = thisFieldOpts.default
      elif thisFieldSpec.defaultValue != undefined:
        column.default = thisFieldSpec.defaultValue
      // Build serialization structures
      columnSequence.push(column.fqcn)
      readPattern.push(['read', fieldKey])
      columnForField[fieldKey] = column

    // Allow flex fields
    for key fieldKey, val thisFieldOpts in fieldOpts:
      if not fieldSpecs[fieldKey]:
        colName = thisFieldOpts.column or fieldKey
        colType = thisFieldOpts.type
        if not colType: continue
        column = _createColumn(this, colName, fieldKey, colType)
        if thisFieldOpts.default != undefined:
          column.default = thisFieldOpts.default
        columnSequence.push(column.fqcn)
        readPattern.push(['read', fieldKey])
        columnForField[fieldKey] = column

    // Build extra data
    this.selectFieldsClause = this.columnSequence.join(',')

    // Allow indices
    for elem indexDefinition in (opts.indices or []):
      idx = new MySQLIndex(this)
      idx.columnNames = indexDefinition.columnNames
      idx.unique = indexDefinition.unique
      this.addIndex(idx)
  } // deriveFromType

// Represents the collection of tables associated with a backend.
export class MySQLTables:
  constructor(backend, database) ->
    this.backend = backend
    this.database = database
    this.tables = Object.create(null)
    this.ordinalTables = []

  // Obtain list of tables from mysql
  _enumerateTables() ->
    this.backend.rawQuery('SHOW TABLES;')
    .then! (rst) =>
      nameColumn = rst?[1]?[0]?.name
      if not nameColumn: return
      tableList = rst[0]
      for elem table in tableList:
        tableName = table[nameColumn]
        this.tables[tableName] = new MySQLTable(this.backend, this.database, tableName)
      this.tables

  // Get metadata for each enumerated table
  _getAllTableMetadata() ->
    Promise.all([...for val tbl in this.tables: [tbl._getTableMetadata()]])

  // Get DDL for all tables
  _getCreateDDL() ->
    [...for val tbl in this.tables: [tbl._toCreateDDL()]]

  // Drop all tables
  _dropAllTables() ->
    Promise.all([...for val tbl in this.tables: [tbl._dropTable()]])

  getTables() ->
    this.tables

  getTableList() ->
    this.ordinalTables

  has(name) ->
    this.tables[name]~looseNotEq(null)

  getOrCreateTableByName(name) ->
    t = this.tables[name]
    if t: return t
    newT = new MySQLTable(this.backend, this.database, name)
    this.tables[name] = newT
    this.ordinalTables.push(newT)
    newT
