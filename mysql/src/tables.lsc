'use @oigroup/lightscript with noEnforcedSubscriptIndentation'

import { sqlTypeMap } from './sqlTypeMap'
import { declaredFieldKeys, declaredFields } from '@ormojo/ephraim'
import { quoteIdentifier, escapeValue, array_move } from './util'

_createColumn(table, colName, fieldKey, colType) ->
  column = new MySQLColumn(table.backend, table.database, table.name, colName)
  table.addColumn(column)
  column.ephraimField = fieldKey
  column.nullable = true
  column.type = colType
  column

export class MySQLColumn:
  constructor(backend, database, tableName, name) ->
    this.backend = backend
    this.database = database
    this.tableName = tableName
    this.name = name
    this.quotedName = quoteIdentifier(name)
    this.fqcn = `${quoteIdentifier(tableName)}.${quoteIdentifier(name)}`

  _fromInformationSchemaRow(row): void ->
    this.nullable = if row.is_nullable == 'YES': true else: false
    this.ordinalPosition = row.ordinal_position
    this.keyType = row.column_key
    this.type = row.column_type
    this.charset = row.character_set_name
    this.collation = row.collation_name
    this.default = row.column_default
    this.autoIncrement = /auto_increment/.test(row.extra)

  _toDDL(): string ->
    nullability = if this.nullable: 'NULL' else: 'NOT NULL'
    def = if this.default: `DEFAULT ${escapeValue(this.default)}` else: ''
    incr = if this.autoIncrement: 'AUTO_INCREMENT' else: ''
    key = match this.keyType:
      | 'PRI': 'PRIMARY KEY'
      | 'UNI': 'UNIQUE'
      | else: ''
    `${quoteIdentifier(this.name)} ${this.type} ${nullability} ${def} ${incr} ${key}`

// Represents a MySQL table
export class MySQLTable:
  constructor(backend, database, name) ->
    this.backend = backend
    this.database = database
    this.name = name
    this.quotedName = quoteIdentifier(name)
    this.columns = {}
    this.ordinalColumns = []

  _dropTable(): Promise<any> ->
    this.backend.rawQuery(`DROP TABLE ${this.quotedName};`)

  // Get columns from MySQL
  _getTableMetadata(): Promise<any> ->
    // Clear existing
    this.columns = {}
    this.ordinalColumns = []
    this.backend.rawQuery('SELECT table_schema, table_name, column_name, ordinal_position, column_default, is_nullable, data_type, character_set_name, collation_name, column_type, column_key, extra FROM information_schema.columns WHERE table_name=? AND table_schema=?;', [this.name, this.database])
    .then! (rst) =>
      for elem colSpec in rst[0] or []:
        col = new MySQLColumn(this.backend, this.database, this.name, colSpec.column_name)
        col._fromInformationSchemaRow(colSpec)
        this.columns[colSpec.column_name] = col
        this.ordinalColumns[colSpec.ordinal_position - 1] = col

  // Generate CREATE TABLE DDL
  _toCreateDDL(unchecked): string ->
    colDDL = [...for elem col in this.ordinalColumns: [col._toDDL!]].join(',')
    `CREATE TABLE ${if unchecked: '' else: 'IF NOT EXISTS'} ${quoteIdentifier(this.name)} (${colDDL})`

  // Insert a column at the ordinally-last position in this table
  addColumn(col: MySQLColumn): void ->
    if this.columns[col.name]:
      throw new Error(`Duplicate column name '${col.name}'`)
    this.ordinalColumns.push(col)
    this.columns[col.name] = col

  // Derive a table from an Ormojo type plus an options object.
  // opts = {
  //    table: string -- name of table, defaults to T.name
  //    fields: {
  //      [ephraimFieldName]: {
  //        column: string -- name of SQL table column for this field, defaults to field name
  //        ignore: boolean -- if true, field will not be mapped to SQL
  //        autoIncrement: boolean -- apply MySQL AUTOINCREMENT
  //        default: string -- MySQL default clause
  //      }
  //      ...
  //    }
  // }
  deriveFromType(T, opts): void -> {
    this.derivedFromType = T
    fieldOpts = opts?.fields or {}
    fieldSpecs = T~declaredFields()
    fieldKeyList = T~declaredFieldKeys().slice()

    // Information used while serializing and deserializing
    columnSequence = [] // SELECT sequence
    readPattern = [['create', T]] // Pattern for deserializing this type of object
    columnForField = Object.create(null) // Field-name-to-column map
    this.columnSequence = columnSequence
    this.readPattern = readPattern
    this.columnForField = columnForField

    // Make id the ordinally-first column if it exists
    if T~declaredFields().id:
      array_move(fieldKeyList, fieldKeyList.indexOf('id'), 0)

    // Enumerate keys and create columns
    for elem fieldKey in fieldKeyList:
      thisFieldSpec = fieldSpecs[fieldKey]
      thisFieldOpts = fieldOpts[fieldKey] or {}
      // Allow fields to be ignored
      if thisFieldOpts.ignore: continue
      // Allow fields to be renamed
      colName = thisFieldOpts.column or fieldKey
      // Only create columns if we can determine the data type
      colType = thisFieldOpts.type or sqlTypeMap(thisFieldSpec.type)
      if not colType: continue
      // Create the column representation
      column = _createColumn(this, colName, fieldKey, colType)
      // Establish column demographics
      if fieldKey == 'id' or thisFieldOpts.primaryKey:
        if this.pkColumnFqcn:
          throw new Error(`MySQLTable: multiple primary keys not allowed for type '${T.name}'`)
        if thisFieldOpts.primaryKey and fieldKey != 'id' and fieldSpecs['id']:
          throw new Error(`MySQLTable: 'id' column must be primary key for type '${T.name}`)
        this.pkColumnFqcn = column.fqcn
        this.pkFieldKey = fieldKey
        if fieldKey == 'id': this.idColumnFqcn = column.fqcn
        column.nullable = false
        column.keyType = 'PRI'
        if thisFieldOpts.autoIncrement:
          column.autoIncrement = true
          // Flag for auto-increment ID; upon insertion we will automatically
          // read the ID from the database
          this.hasAutoIncrementId = true
      if thisFieldOpts.default != undefined:
        column.default = thisFieldOpts.default
      elif thisFieldSpec.defaultValue != undefined:
        column.default = thisFieldSpec.defaultValue
      // Build serialization structures
      columnSequence.push(column.fqcn)
      readPattern.push(['read', fieldKey])
      columnForField[fieldKey] = column

    // Allow flex fields
    for key fieldKey, val thisFieldOpts in fieldOpts:
      if not fieldSpecs[fieldKey]:
        colName = thisFieldOpts.column or fieldKey
        colType = thisFieldOpts.type
        if not colType: continue
        column = _createColumn(this, colName, fieldKey, colType)
        if thisFieldOpts.default != undefined:
          column.default = thisFieldOpts.default
        columnSequence.push(column.fqcn)
        readPattern.push(['read', fieldKey])
        columnForField[fieldKey] = column

    // Build extra data
    this.selectFieldsClause = this.columnSequence.join(',')
  } // deriveFromType

// Represents the collection of tables associated with a backend.
export class MySQLTables:
  constructor(backend, database) ->
    this.backend = backend
    this.database = database
    this.tables = Object.create(null)
    this.ordinalTables = []

  // Obtain list of tables from mysql
  _enumerateTables() ->
    this.backend.rawQuery('SHOW TABLES;')
    .then! (rst) =>
      nameColumn = rst?[1]?[0]?.name
      if not nameColumn: return
      tableList = rst[0]
      for elem table in tableList:
        tableName = table[nameColumn]
        this.tables[tableName] = new MySQLTable(this.backend, this.database, tableName)
      this.tables

  // Get metadata for each enumerated table
  _getAllTableMetadata() ->
    Promise.all([...for val tbl in this.tables: [tbl._getTableMetadata()]])

  // Get DDL for all tables
  _getCreateDDL() ->
    [...for val tbl in this.tables: [tbl._toCreateDDL()]]

  // Drop all tables
  _dropAllTables() ->
    Promise.all([...for val tbl in this.tables: [tbl._dropTable()]])

  getTables() ->
    this.tables

  getTableList() ->
    this.ordinalTables

  has(name) ->
    this.tables[name]~looseNotEq(null)

  getOrCreateTableByName(name) ->
    t = this.tables[name]
    if t: return t
    newT = new MySQLTable(this.backend, this.database, name)
    this.tables[name] = newT
    this.ordinalTables.push(newT)
    newT
