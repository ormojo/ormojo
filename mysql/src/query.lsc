import { Query, Cursor, ResultSet } from '@ormojo/ormojo'
import { escapeValue as q } from './util'

export Field(T, field) ->
  (query) ->
    query.backend._getTableForType(T)?.columnForField[field]?.fqcn

export RawOp(field, o, val) ->
  (query, clause): void ->
    col = if typeof(field) == 'function':
      field(query)
    else:
      query.columnLookup[field]?.fqcn
    if col:
      clause.push(`${col}${o}${val}`)
    else:
      throw new Error(`MySQLQuery: could not find column for field '${field}'`)
    clause

export Op(field, o, val) ->
  RawOp(field, o, q(val))

export In(field, vals) ->
  sqlSet = [...for elem x in vals: [q(x)]].join(',')
  RawOp(field, ' IN ', '(' + sqlSet + ')')

export Eq(field, val) -> Op(field, '=', val)

export Not(arg) ->
  (query, clause): void ->
    clause.push(`NOT ${arg(query, clause)}`)

export Logical(op, ...args) ->
  (query, clause): void ->
    myClauses = []
    for elem arg in args: arg(query, myClauses)
    if myClauses.length == 1:
      clause.push(myClauses[0])
    elif myClauses.length > 1:
      andedClauses = myClauses.map(x -> `(${x})`).join(` ${op} `)
      clause.push(`(${andedClauses})`)

export And(...args) -> Logical("AND", ...args)
export Or(...args) -> Logical("OR", ...args)

export class MySQLQuery extends Query:
  constructor(backend) ->
    super(backend)

  Op(field, op, val) -> Op(field, op, val)
  Eq(field, val) -> Op(field, '=', val)
  Not(op) -> Not(op)
  And(...args) -> Logical("AND", ...args)
  Or(...args) -> Logical("OR", ...args)
  In(field, vals) -> In(field, vals)

  setType(T) ->
    super.setType(T)
    tbl = this.backend._getTableForType(T)
    this.columnLookup = tbl.columnForField
    this.fieldsClause = tbl.selectFieldsClause
    this.fromClause = tbl.quotedName
    this.readPattern = tbl.readPattern
    this

  setQuery(other) ->
    Object.assign(this, other)

  resumeFrom(cursor) ->
    this.setQuery(cursor.query)
    this.offset = cursor.offset
    this.limit = cursor.limit
    this.total = cursor.total
    this

  setOffset(offset) ->
    this.offset = offset
    this

  setLimits(offset, limit, total) ->
    this.total = total
    this.setOffset(offset).setLimit(limit)

  where(build) ->
    clause = []
    build(this, clause)
    if clause[0]:
      this.whereClause = clause[0]
    else:
      throw new Error('Invalid query builder')
    this

  orderBy(field, qualifier = 'ASC') ->
    col = this.columnLookup[field]?.quotedName
    if not col: throw new Error(`MySQLQuery.orderBy: no column for field '${field}'`)
    this.orderByClause = `ORDER BY ${col} ${qualifier}`
    this

  // If true, the driver will run a `COUNT(*)` after running the query
  // for pagination purposes
  shouldCount(): boolean ->
    if this.offset == 0:
      true
    else:
      false

  _getOffsetClause() ->
    if this.limit:
      if this.offset:
        `LIMIT ${this.limit} OFFSET ${this.offset}`
      else:
        `LIMIT ${this.limit}`
    else:
      ''

  _getOrderByClause() ->
    if this.orderByClause: this.orderByClause else: ''

  _getFieldsClause() ->
    if typeof(this.fieldsClause) == 'string':
      this.fieldsClause
    elif Array.isArray(this.fieldsClause):
      this.fieldsClause.join(',')
    else:
      // TODO: error here?
      ''

  _getFromClause() ->
    this.fromClause

  _getWhereClause() ->
    if this.ids:
      ids = this.ids
      col = this.columnLookup['id'].quotedName
      if ids.length > 1:
        set = [...for elem id in ids: if id~looseNotEq(null): [q(id)]]
        if set.length == 0: null else: `${col} IN (${set.join(',')})`
      else:
        if ids[0]~looseEq(null): null else: `${col}=${q(ids[0])}`
    else:
      this.whereClause

  _getSQL() ->
    if this.sql:
      this.sql
    else:
      where = this._getWhereClause()
      if where == null: return null
      `SELECT ${this._getFieldsClause()} FROM ${this._getFromClause()} WHERE ${where} ${this._getOrderByClause()} ${this._getOffsetClause()}`

  _getDeleteSQL() ->
    if this.sql:
      this.sql
    else:
      where = this._getWhereClause()
      if where == null: return null
      `DELETE FROM ${this._getFromClause()} WHERE ${where}`

  _getCountSQL() ->
    if this.sql:
      this.sql
    else:
      where = this._getWhereClause()
      if where == null: return null
      `SELECT COUNT(*) FROM ${this._getFromClause()} WHERE ${where}`

export class MySQLCursor extends Cursor:
  constructor(query) ->
    super()
    this.query = query

  getTotalResultCount() -> this.total

  getRemainingResultCount() -> this.total - this.offset

  setFromOffset(offset, limit, total) ->
    this.offset = offset
    this.limit = limit
    this.total = total
    this

export class MySQLResultSet extends ResultSet:
  constructor(backend, data) ->
    super(backend, data or [])

  getTotalResultCount() ->
    this.total

  _paginate(sourceQuery, total): void ->
    count = this.results.length

    this.total = total

    // If we couldn't retrieve a full page of results, we're at the end
    if count == 0 or count < sourceQuery.limit:
      this.cursor = null
      return

    nextOffset = (sourceQuery.offset or 0) + count
    nextLimit = sourceQuery.limit or count
    this.cursor = new MySQLCursor(sourceQuery).setFromOffset(nextOffset, nextLimit, total)

  getCursor() -> this.cursor

  nextPage() ->
    if this.cursor:
      qry = this.backend.createQuery().resumeFrom(this.cursor)
      this.backend.find(qry)
    else:
      Promise.resolve(null)
