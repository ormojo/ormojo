'use @oigroup/lightscript with noEnforcedSubscriptIndentation'

import { forEachField, forEachChangedField, rawSet, clearDelta, isa, PrimitiveType, OpaqueType } from '@ormojo/ephraim'
import { AsyncSink, SinkResult, Timestamped } from '@ormojo/ormojo'
import { escapeValue as q, reflect } from './util'
import { MySQLTable } from './metadata/table'

class MySQLSinkResult extends SinkResult:
  constructor() ->
    this.results = []
    this._err = null

  _pushSuccess() ->
    this.results.push(true)

  _pushFailure(err) ->
    if not this._err: this._err = err
    this.results.push(err)

  _lastResultWasSuccess() ->
    res = this.results
    if res.length > 0 and res[res.length - 1] == true: true else: false

  firstError() -> this._err
  hasError() -> if this._err: true else: false

handleTimestamped(instance) ->
  if instance~isa(Timestamped):
    if not instance.createdAt: instance.createdAt = new Date()
    instance.updatedAt = new Date()

// Convert value into SQL assignment
toSqlValue(val, T) ->
  if (not T) or (T instanceof PrimitiveType):
    q(val)
  elif T instanceof OpaqueType:
    q(T.stringify(val))
  else:
    // XXX: probably won't work
    q(val)

getInsertQueryForInstance(instance, tbl: MySQLTable) ->
  columnForField = tbl.columnForField
  colNames = []
  colVals = []
  handleTimestamped(instance)
  instance~forEachField! (k, v, T): void ->
    if v != undefined:
      col = columnForField[k]
      if col:
        colNames.push(col.quotedName)
        colVals.push(toSqlValue(v, T?.type))

  `INSERT INTO ${tbl.quotedName} (${colNames.join(',')}) VALUES (${colVals.join(',')})`

getUpdateQueryForInstance(instance, tbl: MySQLTable) ->
  // Formulate SET clause
  columnForField = tbl.columnForField
  subclauses = []
  handleTimestamped(instance)
  instance~forEachChangedField! (k, v, T): void ->
    if v == undefined: now v = null
    col = columnForField[k]
    if col:
      subclauses.push(`${col.quotedName}=${toSqlValue(v, T?.type)}`)

  `UPDATE ${tbl.quotedName} SET ${subclauses.join(',')} WHERE ${tbl.pkColumnFqcn}=${q(instance[tbl.pkFieldKey])}`

getUpsertQueryForInstance(instance, tbl: MySQLTable) ->
  columnForField = tbl.columnForField
  colNames = []
  colVals = []
  subclauses = []
  handleTimestamped(instance)
  instance~forEachField! (k, v, T): void ->
    if v != undefined:
      col = columnForField[k]
      if col:
        colNames.push(col.quotedName)
        quotedValue = toSqlValue(v, T?.type)
        colVals.push(quotedValue)
        subclauses.push(`${col.quotedName}=${quotedValue}`)

  `INSERT INTO ${tbl.quotedName} (${colNames.join(',')}) VALUES (${colVals.join(',')}) ON DUPLICATE KEY UPDATE ${subclauses.join(',')}`

getCrupsertQueryForInstance(instance, tbl: MySQLTable) ->
  if instance._isNewRecord:
    getInsertQueryForInstance(instance, tbl)
  else if instance.id~looseNotEq(null):
    getUpdateQueryForInstance(instance, tbl)
  else:
    getUpsertQueryForInstance(instance, tbl)

getDeleteQueryForInstance(instance, tbl: MySQLTable) ->
  `DELETE FROM ${tbl.quotedName} WHERE ${tbl.pkColumnFqcn}=${q(instance[tbl.pkFieldKey])}`

shouldThrowFirstError(data, opts) ->
  if opts?.throwFirstError == true:
    true
  else if opts?.throwFirstError == false:
    false
  else if data.length == 1:
    true
  else:
    false

updateInstanceFromQueryResult(inst, rst) ->
  // For auto ID generation, pull ID back into ephraim entity
  // TODO: verify if table is an autoincrement table before doing this
  iid = rst[0].insertId
  if iid > 0: rawSet(inst, 'id', iid)
  // Flush delta
  inst~clearDelta!
  if inst._isNewRecord: inst._isNewRecord = undefined

query(backend, builder, data, opts) ->
  Promise.all([...for elem datum in data:
    [backend.rawQuery(builder(datum, backend._getTableForInstance(datum)))~reflect!]
  ])
  .then! (results) ->
    result = new MySQLSinkResult()
    for idx i, elem r in results:
      if r.status == 'resolved':
        updateInstanceFromQueryResult(data[i], r.value)
        result._pushSuccess(r.value)
      else:
        result._pushFailure(r.value)
    if shouldThrowFirstError(data, opts) and result.hasError():
      throw result.firstError()
    result

deleteQuery(backend, data, opts) ->
  Promise.all([...for elem datum in data:
    [backend.rawQuery(getDeleteQueryForInstance(datum, backend._getTableForInstance(datum)))~reflect!]
  ])
  .then! (results) ->
    result = new MySQLSinkResult()
    for elem r in results:
      if r.status == 'resolved':
        result._pushSuccess(r.value)
      else:
        result._pushFailure(r.value)
    if shouldThrowFirstError(data, opts) and result.hasError():
      throw result.firstError()
    result

export class MySQLSink extends AsyncSink:
  constructor(opts) ->
    super(opts)
    this.backend = opts.backend
    this.log = opts.log

  create(data, opts) ->
    query(this.backend, getInsertQueryForInstance, data, opts)

  update(data, opts) ->
    query(this.backend, getUpdateQueryForInstance, data, opts)

  upsert(data, opts) ->
    query(this.backend, getUpsertQueryForInstance, data, opts)

  crupsert(data, opts) ->
    query(this.backend, getCrupsertQueryForInstance, data, opts)

  delete(data, opts) ->
    deleteQuery(this.backend, data, opts)

  deleteById(tbl, ids) ->
    qry = if Array.isArray(ids):
      set = [...for elem id in ids: q(id)].join(',')
      `DELETE FROM ${tbl.quotedName} WHERE ${tbl.pkColumnFqcn} IN (${set})`
    else:
      `DELETE FROM ${tbl.quotedName} WHERE ${tbl.pkColumnFqcn}=${q(ids)}`

    this.backend.rawQuery(qry)
    .then! ->
      true
