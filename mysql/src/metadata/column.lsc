import { quoteIdentifier, escapeValue } from '../util'
import { types } from '@ormojo/ephraim'

sameCharset(lhs, rhs) ->
  (lhs~looseEq(null)) or (rhs~looseEq(null)) or (lhs == rhs)

sameDefault(lhs, rhs) ->
  (((lhs == null) or (lhs == undefined)) and ((rhs == null) or (rhs == undefined))) or
  String(lhs) == String(rhs)

sameKeyType(lhs, rhs) ->
  // Both falsy = no key here
  if Boolean(lhs) == false and Boolean(rhs) == false: return true
  // We only care about PRI keys. UNI and MUL keys are handled by index part
  if lhs != 'PRI' and rhs != 'PRI': return true
  // Must both be PRI
  lhs == rhs

sameColumnType(lhs, rhs) ->
  now lhs = lhs.toLowerCase!
  now rhs = rhs.toLowerCase!
  if lhs == rhs: return true
  if lhs == 'boolean' and rhs == 'tinyint(1)': return true
  if lhs == 'tinyint(1)' and rhs == 'boolean': return true
  false

export class MySQLColumn:
  constructor(backend, database, tableName, name) ->
    this.backend = backend
    this.database = database
    this.tableName = tableName
    this.name = name
    this.quotedName = quoteIdentifier(name)
    this.fqcn = `${quoteIdentifier(tableName)}.${quoteIdentifier(name)}`

  toJSON() -> {
    type: 'MySQLColumn'
    tableName: this.tableName
    name: this.name
    dataType: this.type
    nullable: !!this.nullable
    default: this.default
    keyType: this.keyType
  }

  setType(ty) ->
    this.type = ty
    if(
      /^CHAR/i.test(ty) or
      /^VARCHAR/i.test(ty) or
      /TEXT/i.test(ty) or
      /^ENUM/i.test(ty) or
      /^SET/i.test(ty)
    ): this.isStringType = true
    else: this.isStringType = false
    this

  setDefault(def) ->
    if(this.type == "boolean" or this.type == "BOOLEAN"):
      this.default = if def: 1 else: 0
    else:
      this.default = def

  setEphraimField(fieldKey, fieldType) ->
    this.ephraimField = fieldKey
    if fieldType == types.json:
      this.readPattern = ['readJson', fieldKey]
    elif fieldType == types.boolean:
      this.readPattern = ['readBool', fieldKey]
    elif fieldType == types.date:
      this.readPattern = ['readDate', fieldKey]
    else:
      this.readPattern = ['read', fieldKey]

  hasSameDefinition(other: MySQLColumn): boolean ->
    (Boolean(this.nullable) == Boolean(other.nullable)) and
    (Boolean(this.autoIncrement) == Boolean(other.autoIncrement)) and
    (sameColumnType(this.type, other.type)) and
    (sameDefault(this.default, other.default)) and
    (sameKeyType(this.keyType, other.keyType)) and
    ((not this.isStringType) or sameCharset(this.charset, other.charset)) and
    ((not this.isStringType) or sameCharset(this.collation, other.collation))

  _fromInformationSchemaRow(row): void ->
    this.nullable = if row.is_nullable == 'YES': true else: false
    this.ordinalPosition = row.ordinal_position
    this.keyType = row.column_key
    this.setType(row.column_type)
    this.charset = row.character_set_name
    this.collation = row.collation_name
    this.default = row.column_default
    this.autoIncrement = /auto_increment/.test(row.extra)

  _getTypeDDL(): string ->
    if not this.isStringType:
      this.type
    elif this.charset or this.collation:
      `${this.type} CHARACTER SET ${this.charset or 'utf8'} COLLATE ${this.collation or 'utf8_general_ci'}`

  _toDDL(): string ->
    nullability = if this.nullable: 'NULL' else: 'NOT NULL'
    def = if this.default != undefined: `DEFAULT ${escapeValue(this.default)}` else: ''
    incr = if this.autoIncrement: 'AUTO_INCREMENT' else: ''
    key = match this.keyType:
      | 'PRI': 'PRIMARY KEY'
      | 'UNI': 'UNIQUE'
      | else: ''
    `${quoteIdentifier(this.name)} ${this.type} ${nullability} ${def} ${incr} ${key}`
