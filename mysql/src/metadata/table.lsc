'use @oigroup/lightscript with noEnforcedSubscriptIndentation'

import { sqlTypeMap } from './sqlTypeMap'
import { declaredFieldKeys, declaredFields } from '@ormojo/ephraim'

import { quoteIdentifier, array_move } from '../util'
import { MySQLColumn } from './column'
import { MySQLForeignKey } from './foreignKey'
import { MySQLIndex } from './indices'

_createColumn(table, colName, fieldKey, fieldType, colType) ->
  column = new MySQLColumn(table.backend, table.database, table.name, colName)
  table.addColumn(column)
  column.setEphraimField(fieldKey, fieldType)
  column.nullable = true
  column.setType(colType)
  column

isZeroish(x) -> (x == 0) or (x == '0')
isOneish(x) -> (x == 1) or (x == '1')

// Represents a MySQL table
export class MySQLTable {
  constructor(backend, database, name) ->
    this.backend = backend
    this.database = database
    this.name = name
    this.quotedName = quoteIdentifier(name)
    this.columns = {}
    this.ordinalColumns = []
    this.indices = {}

  toJSON() -> {
    type: 'MySQLTable'
    name: this.name
    columns: [...for elem col in this.ordinalColumns: [col.toJSON()]]
    indices: {...for key k, val v in this.indices: {[k]: v.toJSON()}}
  }

  _dropTable(): Promise<any> ->
    this.backend.rawQuery(`DROP TABLE IF EXISTS ${this.quotedName};`)

  _createColumnForInformationSchemaRow(row): void ->
    col = new MySQLColumn(this.backend, this.database, this.name, row.COLUMN_NAME)
    col._fromInformationSchemaRow(row)
    this.columns[row.COLUMN_NAME] = col
    this.ordinalColumns[row.ORDINAL_POSITION - 1] = col

  _getForeignKeys(): Promise<void> ->
    this.backend.rawQuery('SELECT CONSTRAINT_NAME, REFERENCED_TABLE_NAME, DELETE_RULE, UPDATE_RULE FROM information_schema.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_SCHEMA=? AND TABLE_NAME=?', [this.database, this.name])
    .then! (rst) =>
      promises = [...for elem fkDef in rst[0] or []:
        fk = new MySQLForeignKey(this)
        fk._fromReferentialConstraintsColumn(fkDef)
        this.addIndex(fk)
        [fk._getColumnsFromInformationSchema!]
      ]
      Promise.all(promises)

  _getDomesticKeys(): Promise<void> ->
    this.backend.rawQuery('SELECT INDEX_NAME, COLUMN_NAME, SEQ_IN_INDEX, NON_UNIQUE FROM information_schema.STATISTICS WHERE TABLE_SCHEMA=? AND TABLE_NAME=? AND INDEX_NAME<>\'PRIMARY\'', [this.database, this.name])
    .then! (rst): void =>
      let currentIndex = null
      for elem ixDef in rst[0] or []:
        if (not this.indices[ixDef.INDEX_NAME]) and isOneish(ixDef.SEQ_IN_INDEX):
          now currentIndex = new MySQLIndex(this)
          currentIndex.name = ixDef.INDEX_NAME
          this.addIndex(currentIndex)
          if isZeroish(ixDef.NON_UNIQUE):
            currentIndex.unique = true

        if currentIndex and (currentIndex.name == ixDef.INDEX_NAME):
          currentIndex.columnNames.push(ixDef.COLUMN_NAME)

  // Get columns from MySQL
  _getTableMetadata(): Promise<any> ->
    // Clear existing
    this.columns = {}
    this.ordinalColumns = []
    this.backend.rawQuery('SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME, ORDINAL_POSITION, COLUMN_DEFAULT, IS_NULLABLE, DATA_TYPE, CHARACTER_SET_NAME, COLLATION_NAME, COLUMN_TYPE, COLUMN_KEY, EXTRA FROM information_schema.columns WHERE TABLE_NAME=? AND TABLE_SCHEMA=?;', [this.name, this.database])
    .then! (rst) =>
      for elem row in rst[0] or []:
        this._createColumnForInformationSchemaRow(row)
      this._getForeignKeys!
    .then! =>
      this._getDomesticKeys!


  // Generate CREATE TABLE DDL
  _toCreateDDL(unchecked): string ->
    createDefs = [
      ...for elem col in this.ordinalColumns: [col._toDDL!]
      ...for val idx in this.indices: [idx._toDDL!]
    ].join(',')
    `CREATE TABLE ${if unchecked: '' else: 'IF NOT EXISTS'} ${quoteIdentifier(this.name)} (${createDefs})`

  // Insert a column at the ordinally-last position in this table
  addColumn(col: MySQLColumn): void ->
    if this.columns[col.name]:
      throw new Error(`Duplicate column name '${col.name}'`)
    this.ordinalColumns.push(col)
    this.columns[col.name] = col

  // Add an index
  addIndex(idx: MySQLIndex): void ->
    this.indices[idx.getName!] = idx

  // Derive a table from an Ormojo type plus an options object.
  // opts = {
  //    table: string -- name of table, defaults to T.name
  //    fields: {
  //      [ephraimFieldName]: {
  //        column: string -- name of SQL table column for this field, defaults to field name
  //        type: string -- MySQL datatype
  //        ignore: boolean -- if true, field will not be mapped to SQL
  //        autoIncrement: boolean -- apply MySQL AUTOINCREMENT
  //        default: string -- MySQL default clause
  //      }
  //      ...
  //    }
  //    indices: [
  //      { columnNames: [col1, ...], unique: boolean }
  //    ]
  // }
  deriveFromType(T, opts): void -> {
    this.derivedFromType = T
    fieldOpts = opts?.fields or {}
    fieldSpecs = T~declaredFields()
    fieldKeyList = T~declaredFieldKeys().slice()

    // Information used while serializing and deserializing
    columnSequence = [] // SELECT sequence
    readPattern = [['create', T]] // Pattern for deserializing this type of object
    columnForField = Object.create(null) // Field-name-to-column map
    this.columnSequence = columnSequence
    this.readPattern = readPattern
    this.columnForField = columnForField

    // Make id the ordinally-first column if it exists
    if T~declaredFields().id:
      array_move(fieldKeyList, fieldKeyList.indexOf('id'), 0)

    // Enumerate keys and create columns
    for elem fieldKey in fieldKeyList:
      thisFieldSpec = fieldSpecs[fieldKey]
      thisFieldOpts = fieldOpts[fieldKey] or {}
      // Ignore transient fields
      if thisFieldSpec.transient: continue
      // Allow fields to be ignored
      if thisFieldOpts.ignore: continue
      // Allow fields to be renamed
      colName = thisFieldOpts.column or fieldKey
      // Only create columns if we can determine the data type
      colType = thisFieldOpts.type or sqlTypeMap(thisFieldSpec.type)
      if not colType: continue
      // Create the column representation
      column = _createColumn(this, colName, fieldKey, thisFieldSpec.type, colType)
      // Establish column demographics
      if fieldKey == 'id' or thisFieldOpts.primaryKey:
        if this.pkColumnFqcn:
          throw new Error(`MySQLTable: multiple primary keys not allowed for type '${T.name}'`)
        if thisFieldOpts.primaryKey and fieldKey != 'id' and fieldSpecs['id']:
          throw new Error(`MySQLTable: 'id' column must be primary key for type '${T.name}`)
        this.pkColumnFqcn = column.fqcn
        this.pkFieldKey = fieldKey
        if fieldKey == 'id': this.idColumnFqcn = column.fqcn
        column.nullable = false
        column.keyType = 'PRI'
        if thisFieldOpts.autoIncrement:
          column.autoIncrement = true
          // Flag for auto-increment ID; upon insertion we will automatically
          // read the ID from the database
          this.hasAutoIncrementId = true
      else:
        if thisFieldOpts.nullable != undefined: column.nullable = thisFieldOpts.nullable
      if thisFieldOpts.default != undefined:
        column.setDefault(thisFieldOpts.default)
      elif thisFieldSpec.defaultValue != undefined:
        column.setDefault(thisFieldSpec.defaultValue)
      // Build serialization structures
      columnSequence.push(column.fqcn)
      readPattern.push(column.readPattern)
      columnForField[fieldKey] = column

    // Allow flex fields
    for key fieldKey, val thisFieldOpts in fieldOpts:
      if not fieldSpecs[fieldKey]:
        colName = thisFieldOpts.column or fieldKey
        colType = thisFieldOpts.type
        if not colType: continue
        column = _createColumn(this, colName, fieldKey, null, colType)
        if thisFieldOpts.default != undefined:
          column.setDefault(thisFieldOpts.default)
        if thisFieldOpts.nullable != undefined: column.nullable = thisFieldOpts.nullable
        columnSequence.push(column.fqcn)
        readPattern.push(column.readPattern)
        columnForField[fieldKey] = column

    // Build extra data
    this.selectFieldsClause = this.columnSequence.join(',')

    // Allow indices
    for elem indexDefinition in (opts.indices or []):
      idx = new MySQLIndex(this)
      idx.columnNames = indexDefinition.columnNames
      idx.unique = indexDefinition.unique
      this.addIndex(idx)
  } // deriveFromType

  _readPatternForField(f) ->
    this.columnForField[f].readPattern


} // MySQLTable
