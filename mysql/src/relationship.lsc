import { Relationship, setBackend, save } from '@ormojo/ormojo'
import { createMemoryDelta as create, assignPlainObject } from '@ormojo/ephraim'
import { MySQLForeignKey } from './metadata/foreignKey'
import { escapeValue as quote } from './util'

export class MySQLRelationship extends Relationship:
  constructor(backend) ->
    super(backend)

  _lookupType(typeField, tblField, T): void ->
    this[typeField]= T
    this[tblField] = this.backend._getTableForType(T)
    if not this[tblField]:
      throw new Error(`Relationship: cannot find table for type '${T.name}'`)

  _lookupColumn(colField, tblField, fieldName): void ->
    this[colField] = this[tblField].columnForField[fieldName]
    if not this[colField]:
      throw new Error(`Relationship: could not map field '${fieldName}' into table '${this[tblField].name}'`)

export class OneToOneRelationship extends MySQLRelationship:
  constructor(backend) ->
    super(backend)

  // eslint-disable-next-line @lightscript/no-unused-vars
  setMultiJoin(priorJoin, foreignType, foreignField) ->
    this

  join(masterType, childType, childJoinField, childObjectField, masterObjectField) ->
    this.masterType = masterType
    this.masterTable = this.backend._getTableForType(masterType)
    if not this.masterTable:
      throw new Error(`Relationship: cannot find table for master type '${masterType.name}'`)
    this.masterColumn = this.masterTable.columnForField['id']
    if not this.masterColumn:
      throw new Error(`Relationship: cannot find master id column`)
    this.masterObjectField = masterObjectField

    this.childType = childType
    this.childJoinField = childJoinField
    this.childTable = this.backend._getTableForType(childType)
    if not this.childTable:
      throw new Error(`Relationship: cannot find table for child type '${childType.name}'`)
    this.childJoinColumn = this.childTable.columnForField[childJoinField]
    if not this.childJoinColumn:
      throw new Error(`Relationship: cannot find child join column`)
    this.childObjectField = childObjectField

    this.joinClause = `${this.masterTable.quotedName} LEFT JOIN ${this.childTable.quotedName} ON ${this.masterColumn.fqcn}=${this.childJoinColumn.fqcn}`

    // Formulate read pattern
    this.selectFieldsClause = this.masterTable.selectFieldsClause + ',' + this.childTable.selectFieldsClause
    this.readPattern = this.masterTable.readPattern.slice()
    this.readPattern.push(["createChild", childType, childObjectField, masterObjectField])
    this.readPattern.push(...this.childTable.readPattern.slice(1))

    this

  // Create a foreign key constraint on the child table.
  createForeignKeyConstraint(onDelete = "CASCADE", onUpdate = "CASCADE") ->
    idx = new MySQLForeignKey(this.childTable).setSingleColumn(this.childJoinColumn.name, this.masterTable.name, this.masterColumn.name)
    idx.onDelete = onDelete
    idx.onUpdate = onUpdate
    this.childTable.addIndex(idx)
    this

  createRelated(master) ->
    child = this.childType~create!~setBackend(this.backend)
    child[this.childJoinField] = master.id
    if this.childObjectField: master[this.childObjectField] = child
    if this.masterObjectField: child[this.masterObjectField] = master
    child

  createQuery() ->
    q = this.backend.createQuery()
    q.columnLookup = this.masterTable.columnForField
    q.fieldsClause = this.selectFieldsClause
    q.fromClause = this.joinClause
    q.readPattern = this.readPattern
    q

export class ManyToManyRelationship extends MySQLRelationship:
  constructor(backend) ->
    super(backend)
    this._extraReadPattern = []
    this._extraFieldsClause = ''

  join(lhsType, rhsType, joinType, joinFieldLHS, joinFieldRHS) ->
    this._lookupType('lhsType', 'lhsTable', lhsType)
    this._lookupColumn('lhsCol', 'lhsTable', 'id')
    this._lookupType('rhsType', 'rhsTable', rhsType)
    this._lookupColumn('rhsCol', 'rhsTable', 'id')
    this._lookupType('joinType', 'joinTable', joinType)
    this._lookupColumn('joinLhsCol', 'joinTable', joinFieldLHS)
    this.joinFieldLHS = joinFieldLHS
    this._lookupColumn('joinRhsCol', 'joinTable', joinFieldRHS)
    this.joinFieldRHS = joinFieldRHS
    this

  extraField(rhsField, joinField) ->
    rp = this.joinTable._readPatternForField(joinField).slice()
    rp[1] = rhsField
    this._extraReadPattern.push(rp)
    this._extraFieldsClause = this._extraFieldsClause + `,${this.joinTable.columnForField[joinField].fqcn}`
    this

  _createRLPattern(): void ->
    if this._rlFieldsClause: return
    this._rlFieldsClause = this.rhsTable.selectFieldsClause + this._extraFieldsClause
    this._rlReadPattern = this.rhsTable.readPattern.concat(this._extraReadPattern)
    this._rlJoinClause = `${this.joinTable.quotedName} LEFT JOIN ${this.rhsTable.quotedName} ON ${this.joinRhsCol.fqcn}=${this.rhsCol.fqcn}`

  linkById(lid, rid, extra) ->
    if lid~looseEq(null) or rid~looseEq(null):
      throw new Error("Relationship.Link: link subjects must have non-null ids")
    relator = this.backend.create(this.joinType)
    if extra: relator~assignPlainObject(extra)
    relator[this.joinFieldLHS] = lid
    relator[this.joinFieldRHS] = rid
    relator~save()

  unlinkById(lid, rid) ->
    if lid~looseEq(null) or rid~looseEq(null):
      throw new Error("Relationship.Link: link subjects must have non-null ids")
    this.backend.rawQuery(`DELETE FROM ${this.joinTable.quotedName} WHERE ${this.joinLhsCol.fqcn}=${quote(lid)} AND ${this.joinRhsCol.fqcn}=${quote(rid)}`)

  link(leftEntity, rightEntity, extra) ->
    this.linkById(leftEntity.id, rightEntity.id, extra)

  unlink(leftEntity, rightEntity) ->
    this.unlinkById(leftEntity.id, rightEntity.id)

  createQueryForRightEntities(leftEntity) ->
    this._createRLPattern()
    q = this.backend.createQuery()
    q.columnLookup = this.rhsTable.columnForField
    q.fieldsClause = this._rlFieldsClause
    q.fromClause = this._rlJoinClause
    q.readPattern = this._rlReadPattern
    q.whereClause = `${this.joinLhsCol.fqcn}=${quote(leftEntity.id)}`
    q

  // Create a foreign key constraint on the join table.
  createForeignKeyConstraint(onDelete = "CASCADE", onUpdate = "CASCADE") ->
    idx = new MySQLForeignKey(this.joinTable).setSingleColumn(this.joinLhsCol.name, this.lhsTable.name, this.lhsCol.name)
    idx.onDelete = onDelete
    idx.onUpdate = onUpdate
    this.joinTable.addIndex(idx)
    idx2 = new MySQLForeignKey(this.joinTable).setSingleColumn(this.joinRhsCol.name, this.rhsTable.name, this.rhsCol.name)
    idx2.onDelete = onDelete
    idx2.onUpdate = onUpdate
    this.joinTable.addIndex(idx2)
    this
