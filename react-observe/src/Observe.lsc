import React from 'react'

classOf(obj) ->
  obj.constructor

export class Observe extends React.Component:
  //////////////////// Lifecycle
  constructor(props) ->
    super(props)
    classOfThis = classOf(this)
    source = classOfThis.getSourceFromProps(props)
    this.state = {
      source
      value: classOfThis.getValueFromSource(source)
      classOfThis
    }

  shouldComponentUpdate(nextProps, nextState) ->
    if nextProps.pure:
      // Pure case: update only if value or source changes
      (nextState.value != this.state.value) or
      (not this.compareSourceToSource(nextState.source, this.state.source))
    else:
      true

  static getDerivedStateFromProps(nextProps, prevState) =>
    // HACK: react does not call this in proper static context (Class.getDerivedStateFromProps)
    // Instead it treats it as an unbound JS function.
    // But we can't use Function.bind() because we need dynamic behavior
    // for subclasses.
    classOfThis = prevState.classOfThis
    if not classOfThis.comparePropsToSource(nextProps, prevState.source):
      source = classOfThis.getSourceFromProps(nextProps)
      value = classOfThis.getValueFromSource(source)
      { source, value }
    else:
      null

  componentDidMount(): void ->
    this.subscribe!

  componentDidUpdate(prevProps, prevState): void ->
    if (not this.compareSourceToSource(this.state.source, prevState.source)):
      this.unsubscribe(prevState.source)
      this.subscribe()

  componentWillUnmount(): void ->
    this.unsubscribe(this.state.source)
    this._hasUnmounted = true

  render() ->
    val = this.state.value
    this.props.children(val)

  /////////////// Subscription handling
  callback(value): void =>
    if this._hasUnmounted: return
    { source } = this.state

    this.setState((state) ->
      if source != state.source: return null
      if value == state.value: return null
      { value }
    )

  // eslint-disable-next-line no-unused-vars
  unsubscribe(source): void ->
    if this.subscription:
      this.subscription.unsubscribe()
      this.subscription = undefined

  subscribe(): void ->
    { source } = this.state
    if not source: return
    observable = this.getObservableFromSource(source)
    value = classOf(this).getValueFromSource(source)
    if (value != undefined) and (value != this.state.value):
      this.setState({value})
    this.subscription = observable.subscribe({next: this.callback})

  //////////////////// Behavioral methods
  // Override in children to customize observable behavior.

  // Compare current state.source to incoming props to determine if the source
  // needs to be changed. Return true if same, false if different.
  static comparePropsToSource(nextProps, prevSource) ->
    nextProps.source == prevSource

  // Compare two state.source values to determine if the source has changed.
  // Return true if same, false if different
  compareSourceToSource(nextSource, prevSource) ->
    nextSource == prevSource

  // Get the state.source value corresponding to the given props
  static getSourceFromProps(props) ->
    props.source

  // Get the Value associated with the given source.
  static getValueFromSource(source) ->
    source?.getValue?()

  // Get the ES7 Observable corresponding to the given state.source along
  // with its initial value, as an { observable, value } pair
  getObservableFromSource(source) ->
    source
