import React from 'react'
import { debug } from './debug'

classOf(obj) ->
  obj.constructor

export class Observe extends React.Component:
  //////////////////// Lifecycle
  constructor(props) ->
    super(props)
    classOfThis = classOf(this)
    source = classOfThis.getSourceFromProps(props)
    this.earlySubscribe(source)
    this.state = {
      source
      value: this._earlyValue
      classOfThis
    }

  shouldComponentUpdate(nextProps, nextState) ->
    if nextProps.pure:
      // Pure case: update only if value or source changes
      (nextState.value != this.state.value) or
      (not this.compareSourceToSource(nextState.source, this.state.source))
    else:
      true

  static getDerivedStateFromProps(nextProps, prevState) =>
    // HACK: react does not call this in proper static context (Class.getDerivedStateFromProps)
    // Instead it treats it as an unbound JS function.
    // But we can't use Function.bind() because we need dynamic behavior
    // for subclasses.
    classOfThis = prevState.classOfThis
    if not classOfThis.comparePropsToSource(nextProps, prevState.source):
      source = classOfThis.getSourceFromProps(nextProps)
      debug("gDSP: source change from props", source)
      { source }
    else:
      null

  componentDidMount(): void ->
    this.subscribe!

  componentDidUpdate(prevProps, prevState): void ->
    if (not this.compareSourceToSource(this.state.source, prevState.source)):
      debug("cDU: source change from prevState", this.state.source)
      this.unsubscribe(prevState.source)
      this.subscribe()

  componentWillUnmount(): void ->
    this.unsubscribe(this.state.source)
    this._hasUnmounted = true

  render() ->
    val = this.state.value
    this.props.children(val)

  /////////////// Subscription handling
  callback(value): void =>
    if this._hasUnmounted: return

    // Early mode
    if this._earlySource:
      this._earlyValue = value
      return

    { source } = this.state

    this.setState((state) ->
      if source != state.source: return null
      if value == state.value: return null
      { value }
    )

  // eslint-disable-next-line no-unused-vars
  unsubscribe(source): void ->
    if this._earlySubscription:
      debug("early unsubscribing due to unsubscribe()")
      this._earlySubscription.unsubscribe()
      this.clearEarlyData()

    if this.subscription:
      debug("unsubscribe", source)
      this.subscription.unsubscribe()
      this.subscription = undefined

  clearEarlyData(): void ->
    debug("clearEarlyData")
    this._earlySubscription = undefined
    this._earlySource = undefined
    this._earlyValue = undefined

  earlySubscribe(source): void ->
    if not source: return
    this._earlySource = source
    debug("getObservable (early subscribe)", source)
    observable = this.getObservableFromSource(source)
    this._earlySubscription = observable.subscribe({next: this.callback})

  earlyResolve(source): boolean ->
    result = if source != this._earlySource:
      // Source changed, unsubscribe
      debug("early unsubscribing due to source change")
      this._earlySubscription.unsubscribe()
      false
    else:
      // Same source, pass subscription through
      debug("early subscription was preserved")
      this.subscription = this._earlySubscription
      true

    // We must re-emit any values emitted between early subscription and now
    // regardless of if the source has changed
    value = this._earlyValue
    this.clearEarlyData()
    if (value != this.state.value): this.setState({value})

    // If sources are same, we're done
    result

  subscribe(): void ->
    { source } = this.state
    // Early source resolution
    if this._earlySource and this.earlyResolve(source): return
    debug("getObservable (late subscribe)", source)
    observable = this.getObservableFromSource(source)
    this.subscription = observable.subscribe({next: this.callback})

  //////////////////// Behavioral methods
  // Override in children to customize observable behavior.

  // Compare current state.source to incoming props to determine if the source
  // needs to be changed. Return true if same, false if different.
  static comparePropsToSource(nextProps, prevSource) ->
    nextProps.source == prevSource

  // Compare two state.source values to determine if the source has changed.
  // Return true if same, false if different
  compareSourceToSource(nextSource, prevSource) ->
    nextSource == prevSource

  // Get the state.source value corresponding to the given props
  static getSourceFromProps(props) ->
    props.source

  // Get the ES7 Observable corresponding to the given state.source along
  // with its initial value, as an { observable, value } pair
  getObservableFromSource(source) ->
    source
