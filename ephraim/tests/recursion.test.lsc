import { entity, field, toPlainObject, assignPlainObject, types, listOf, createMemory as create, augment, hydratePlainObject, Entity } from '@ormojo/ephraim'

test! 'toPlainObject', ->
  @entity({name: "E"}) class E extends Entity:
    @field() nonFlex
    @field(types.date) d

  e = create(E)
  e.nonFlex = 1
  e.d = new Date()
  e.flex = 2
  e._private = 3
  console.log(e~toPlainObject({includeTypeStamp: true}))

test! 'toPlainObject json date', ->
  @entity({name: "E"}) class E extends Entity:
    @field(types.date) d

  e = create(E)
  e.d = new Date()
  console.log(e~toPlainObject({includeTypeStamp: true, toJson: true}))

test! 'toPlainObject transients', ->
  @entity({name: "E"}) class E extends Entity:
    @field({type: types.any, transient: true}) t

  e = create(E)
  e.flex = 2
  e.t = 1
  console.log(e~toPlainObject({includeTypeStamp: true}))
  console.log(e~toPlainObject({includeTypeStamp: true, includeTransients: true}))

test! "basic assign", ->
  @entity({name: "E"}) class E extends Entity:
    @field(types.string) str

  e = create(E)
  e~assignPlainObject({ str: "str" })
  console.log(e~toPlainObject!)
  expect(e~toPlainObject!).toEqual({str: "str"})

test! "deep assign", ->
  @entity({name: "E"}) class E extends Entity:
    @field(types.string) str

  @entity({name: "D"}) class D extends Entity:
    @field(E) subE

  d = create(D)
  d~assignPlainObject({ subE: { str: "str" } })
  console.log(d~toPlainObject!)
  expect(d~toPlainObject!).toEqual({ subE: { str: "str" } })

test! "primitive list assign", ->
  @entity({name: "E"}) class E extends Entity:
    @field(listOf(types.string)) strs

  e = create(E)
  e~assignPlainObject({strs: ["1", "2", "3"]})
  console.log(e~toPlainObject!)
  expect(e~toPlainObject!).toEqual({strs: ["1", "2", "3"]})

test! "entity list assign", ->
  @entity({name: "E"}) class E extends Entity:
    @field(types.string) str

  @entity({name: "D"}) class D extends Entity:
    @field(listOf(E)) es

  d = create(D)
  debugger
  d~assignPlainObject({ es: [ { str: "1"}, { str: "2"}, { str: "3"} ] })
  console.log(d~toPlainObject!)
  expect(d~toPlainObject!).toEqual({ es: [ { str: "1"}, { str: "2"}, { str: "3"} ] })

test! 'circular assign entity', ->
  @entity({name: "Parent"}) class Parent extends Entity:
    @field() child

  @entity({name: "Child"}) class Child extends Entity:
    @field(Parent) parent
    @field() data

  Parent~augment({ child: { type: Child }})

  debugger

  p = create(Parent)
  p.child = create(Child)
  p.child.parent = p
  p.child.data = 123

  plain = p~toPlainObject!

  p2 = create(Parent)
  p2~assignPlainObject(plain)
  expect(p2.child.parent).toBe(p2)
  expect(p~toPlainObject!).toEqual(p2~toPlainObject!)

test! 'circular assign list', ->
  @entity({name: "E"}) class E extends Entity:
    @field(types.string) str

  loe = create(listOf(E))
  e1 = create(E)
  e1.str = "hi"
  e2 = create(E)
  e2.str = "bye"
  loe.push(e1, e2, e2)
  expect(loe.get(1)).toBe(loe.get(2))

  plain = loe~toPlainObject!
  console.log(plain)

  loe2 = create(listOf(E))
  debugger
  loe2~assignPlainObject(plain)
  console.log(loe2~toPlainObject!)
  expect(loe2.get(1)).toBe(loe2.get(2))

test! 'entity type unpickling', (): void ->
  @entity({name: "Base"}) class Base extends Entity:
    @field() b

  @entity({name: "Child1"}) class Child1 extends Base:
    @field() c1

  @entity({name: "Child2"}) class Child2 extends Base:
    @field() c2

  @entity({name: "Container"}) class Container extends Entity:
    @field(Base) x1
    @field(Base) x2

  c = create(Container)
  c.x1 = create(Child1)
  c.x2 = create(Child2)

  obj = c~toPlainObject({ includeTypeStamp: true })
  console.log(obj)

  c2 = obj~hydratePlainObject({
    typeMap(name) ->
      match name:
        | "Container": create(Container)
        | "Child1": create(Child1)
        | "Child2": create(Child2)
  })

  console.log(c2)
  expect(c2~toPlainObject({ includeTypeStamp: true })).toEqual(obj)
