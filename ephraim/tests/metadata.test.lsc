'use @oigroup/lightscript with flippedImports'

import '@ormojo/ephraim': {
  entity, field, types
  declaredFields, declaredFieldKeys
  fieldKeys, flexFieldKeys, forEachField
  createMemory as create
  typeOf, underlyingTypeOfType
}


test! "fields by class", ->
  @entity({name: "E"}) class E:
    @field() anyField

  @entity({name: "D"}) class D extends E:
    @field(types.string) strField

  expect! E~declaredFields()['anyField']
    .toBeTruthy!

  expect! D~declaredFields()['strField']
    .toBeTruthy!

  expect! E~declaredFieldKeys()
    .toEqual(['anyField'])

  expect! D~declaredFieldKeys()
    .toEqual(['anyField', 'strField'])

  expect! D~declaredFields()['nope']
    .toBeFalsy!

test! "illegal field names", ->
  expect!
    ->
      @entity({name: "Bad1"}) class Bad1:
        @field() _underscored
    .toThrow("Field '_underscored' may not begin with '_' or contain '.'")
  // TODO: dotted example once class properties + decorators work right

test! "instance field metadata", ->
  @entity({name: "E"}) class E:
    @field() anyField

  @entity({name: "D"}) class D extends E:
    @field(types.string) strField

  e = create(E)
  d = create(D)
  d.flex = 1
  d._notFlex = 2
  d._veryNotFlex = -> 3

  d~forEachField((k, v, spec) -> console.log(k, v, spec))
  expect(e~declaredFields()).toEqual(E~declaredFields())
  expect(d~declaredFields()).toEqual(D~declaredFields())
  expect(e~fieldKeys()).toEqual(E~declaredFieldKeys())
  expect(d~fieldKeys()).not.toEqual(D~declaredFieldKeys())
  expect(d~flexFieldKeys()).toEqual(['flex'])

test! "primitive defaults metadata", ->
  @entity({name: "E"}) class E:
    @field(types.string) F = "default"
    @field(types.string) G
    @field(types.string) H = -> "initializerFunction"

  e = create(E)
  fields = e~declaredFields()

  console.log(fields['F'], fields['G'])
  expect(fields['F'].defaultValue).toEqual('default')
  expect(fields['G'].defaultValue).toEqual(undefined)
  expect(fields['H'].defaultValue).toBe(undefined)
  expect(e.H).toBe('initializerFunction')


test! "underlying types", ->
  @entity({name: "E"}) class E:
    @field() anyField

  e = create(E)

  T1 = typeOf(e)
  T2 = underlyingTypeOfType(T1)
  console.log("T1", T1)
  console.log("T2", T2)

  expect(e~typeOf()).not.toBe(E)
  expect(e~typeOf()~underlyingTypeOfType()).toBe(E)
