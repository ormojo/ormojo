import { typeFrom } from './types/type'

export fieldsSymbol = Symbol.for("ephraim.fields")
export dataSymbol = Symbol.for("ephraim.data")
export rawSetSymbol = Symbol.for("ephraim.rawSet")

// Get fields
export declaredFields(x) ->
  T = typeFrom(x) or typeFrom(x.constructor)
  T.fields

export hasDeclaredField(x, f) ->
  T = typeFrom(x) or typeFrom(x.constructor)
  if T.fields[f]: true else: false

export declaredFieldKeys(x) ->
  T = typeFrom(x) or typeFrom(x.constructor)
  Object.keys(T.fields)

export primitiveFields(x) ->
  T = typeFrom(x) or typeFrom(x.constructor)
  T.primitiveFields

export primitiveFieldKeys(x) ->
  T = typeFrom(x) or typeFrom(x.constructor)
  Object.keys(T.primitiveFields)

export opaqueFields(x) ->
  T = typeFrom(x) or typeFrom(x.constructor)
  T.opaqueFields

export opaqueFieldKeys(x) ->
  T = typeFrom(x) or typeFrom(x.constructor)
  Object.keys(T.opaqueFields)

// Get keys of flex fields -- undeclared fields not present on the
// prototype, but present on the object itself.
export flexFieldKeys(ent) ->
  [...for key k, val v in ent:
    if k.charCodeAt(0) != 95 and typeof(v) != "function": [k]
  ]

// Get all field keys, flex and declared
export fieldKeys(ent) ->
  [
    ...for key k in ent[fieldsSymbol]: [k]
    ...for key k, val v in ent:
      if k.charCodeAt(0) != 95 and typeof(v) != "function": [k]
  ]

// Iterate over all field keys and values, flex and declared
export forEachField(ent, f): void ->
  // Declared fields
  for key k, val spec in ent[fieldsSymbol]:
    f(k, ent[k], spec)

  // Flex fields
  for elem k in Object.keys(ent):
    if k.charCodeAt(0) != 95:
      v = ent[k]
      if typeof(v) != "function":
        f(k, v)

// Directly set a field on an entity without triggering observers, deltas, et cetera
export rawSet(ent, fieldKey, val): void ->
  if ent[fieldsSymbol][fieldKey]:
    ent[rawSetSymbol](fieldKey, val)
  else:
    ent[fieldKey] = val
