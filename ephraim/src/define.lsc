// Helpers for defining types
import { typeFrom, isType, EntityType } from './type'
import { any } from './primitiveTypes'
import { fieldsSymbol } from './fields'

// Associate a prototype with an Ephraim EntityType
export bootstrapPrototype(proto, typeClass): void ->
  if not proto.hasOwnProperty(fieldsSymbol):
    // Create EntityType
    T = new typeClass(proto.constructor.name)
    // Associate it with the prototype
    T.bootstrapFromPrototype(proto)

normalizeFieldSpec(spec) ->
  if not spec: return { type: any }
  if spec~isType!: return { type: typeFrom(spec) }
  if typeof(spec) != "object":
    throw new Error("Field specification must be an object. (Did you forget () after a decorator?)")
  spec.type = typeFrom(spec.type)
  if not spec.type:
    throw new Error("Field specification must have a `type` key which is an ephraim type.")

  spec

// @field decorator
export field(spec) ->
  (proto, key, descriptor) ->
    // Key may not contain dot or begin with underscore
    if ( /\./.test(key) or /^_/.test(key) ):
      throw new Error(`Field '${key}' may not begin with '_' or contain '.'`)

    // Generate entity prototype
    bootstrapPrototype(proto, EntityType)
    T = typeFrom(proto.constructor)

    // Normalize field specification; allow existing fields to be extended
    // via Object.assign
    lastSpec = T.fields[key]
    nextSpec = if lastSpec:
      normalizeFieldSpec(Object.assign({}, lastSpec, spec))
    else:
      normalizeFieldSpec(spec)
    if descriptor.initializer != undefined: nextSpec.initializer = descriptor.initializer

    // Apply field descriptor to type
    T.defineField(key, nextSpec)
    T.nativeProperties[key] = true
    {
      configurable: true, enumerable: true
      get: -> undefined
      set: -> throw new Error("setting abstract entity property")
    }

normalizeEntitySpec(spec) ->
  if spec == undefined: now spec = {}
  if typeof(spec) != "object":
    throw new Error("Entity specification must be an object. (Did you forget () after a decorator?)")
  spec

// @entity decorator
export entity(spec) ->
  now spec = normalizeEntitySpec(spec)
  let inherits = spec.inherits
  if inherits: delete spec.inherits

  (constructor) ->
    proto = constructor.prototype
    bootstrapPrototype(proto, EntityType)
    T = typeFrom(proto.constructor)
    Object.assign(T.entitySpec, spec)
    T.freezeNativeProperties()
    if inherits:
      T.extendsAprototypically([
        ...for elem e in inherits: [typeFrom(e)]
      ])

    throwOnlyConstructor = () ->
      throw new Error("cannot construct entity without a driver")

    T.setEntityConstructor(throwOnlyConstructor)

    throwOnlyConstructor

// Augment specifications for fields
export augmentField(T, field, spec): void ->
  now T = typeFrom(T)
  if T.fields[field]:
    nextSpec = normalizeFieldSpec(Object.assign({}, T.fields[field], spec))
    T.defineField(field, nextSpec)

export augment(T, specs): void ->
  for key k, val v in specs: augmentField(T, k, v)

export setFieldType(T, field, type): void ->
  augmentField(T, field, { type } )
