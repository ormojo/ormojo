import { singleton } from './singleton'
import { forEachField, fieldsSymbol } from './fields'

export typeSymbol = Symbol.for("ephraim.type")
export underlyingTypeSymbol = Symbol.for("ephraim.underlyingType")

// Get all keys, enumerable or otherwise, up the prototype chain,
// excluding Object.
_getAllPrototypeKeys(buf, proto): void ->
  if (not proto) or (proto == Object.prototype): return

  for elem name in Object.getOwnPropertyNames(proto): buf.push(name)

  _getAllPrototypeKeys(buf, Object.getPrototypeOf(proto))

getAllPrototypeKeys(proto) ->
  buf = []
  _getAllPrototypeKeys(buf, proto)
  buf

getPropertyDescriptorFromPrototypeChain(proto, key) ->
  if (not proto) or (proto == Object.prototype): return undefined

  desc = Object.getOwnPropertyDescriptor(proto, key)
  if desc: return desc

  getPropertyDescriptorFromPrototypeChain(Object.getPrototypeOf(proto), key)

export Type = singleton("Type", ->
  class Type:
    constructor(name) ->
      this[typeSymbol] = this
      this.extra = {}
      this.name = name
      this.typeIdentity = Symbol(name)

    extends(otherT): void ->
      this.extra = Object.assign({}, otherT?.extra)

    isKindOf(otherT): boolean ->
      otherT == this

    // Check that x is an instance of this type
    // eslint-disable-next-line no-unused-vars
    validate(x): boolean ->
      false

    // Called when a field of this type was defined on an EntityType.
    // Used to set up the `defineProperty` hooks, et al.
    // eslint-disable-next-line no-unused-vars
    fieldOfTypeWasDefined(defineeType, key, spec): void ->
      return

    // Descend into this object recursively
    recurseLeft(left) -> left

    // Descend into another object recursively, mapping it onto this object
    // eslint-disable-next-line no-unused-vars
    recurseRight(left, right): void -> return

    // Set type extra data. This is inherited (via Object.assign) when a new
    // type is created based on this one.
    setExtra(key, value) -> this.extra[key] = value

    // Get type extra data
    getExtra(key) -> this.extra[key]

    // Function called when the user attempts to create an observable version
    // of an object of this type.
    createObservableGhost() ->
      throw new Error(`Type '${this.name}' does not define an observable interface`)
)

export PrimitiveType = singleton("PrimitiveType", ->
  class PrimitiveType extends Type:
    constructor(name) ->
      super(name)

    createObservableGhost() ->
      throw new Error("primitive types cannot be observed")

    initialize(entity, spec, creator, initializer) ->
      initializer.call(entity)
)

export ComplexType = singleton("ComplexType", ->
  class ComplexType extends Type:
    constructor(name) ->
      super(name)
      this.isa = { [this.typeIdentity]: true }

    extends(otherT): void ->
      if not (otherT instanceof ComplexType):
        throw new Error(`Invalid inheritance: complex type '${this.name}' cannot extend non-complex type '${otherT.name}'`)
      super.extends(otherT)
      for elem sym in Object.getOwnPropertySymbols(otherT.isa):
        this.isa[sym] = true

    isKindOf(otherT): boolean ->
      otherTypeIdentity = otherT.typeIdentity
      if otherTypeIdentity and this.isa[otherTypeIdentity]: true else: false
)

export EntityType = singleton("EntityType", ->
  class EntityType extends ComplexType:
    constructor(name) ->
      super(name)
      this.entitySpec = {}
      this.fields = {}
      this.nativeProperties = {}

    defineField(key, spec): void ->
      spec.key = key
      this.fields[key] = spec
      spec.type.fieldOfTypeWasDefined(this, key, spec)

    initialize(entity, spec, creator, initializer) ->
      creator(this)

    setEntityConstructor(constr): void ->
      // Wire javascript prototype propertly
      proto = this.entityPrototype
      constr.prototype = proto
      proto.constructor = constr

      // Wire Ephraim type properly
      setType(constr, this)
      this.entityConstructor = constr

      // Set constructor name to typename
      Object.defineProperty(constr, "name", { value: this.name })

    extends(otherT): void ->
      if not (otherT instanceof EntityType):
        throw new Error(`Invalid inheritance: entity type '${this.name}' cannot extend non-entity type '${otherT.name}'`)
      super.extends(otherT)

      // Native fields override those from extensions
      for key k, val v in otherT.fields:
        if not this.nativeProperties[k]:
          this.fields[k] = v
      Object.assign(this.entitySpec, otherT.entitySpec)

    extendsPrototypically(otherT): void ->
      this.extends(otherT)
      this.extendsPrototypically = otherT

    extendsAprototypically(otherTs): void ->
      for elem otherT in otherTs:
        this.extends(otherT)
        this.adoptPrototypeProperties(otherT)

    adoptPrototypeProperties(otherT): void ->
      // Transfer own AND non-own properties from otherT's prototype
      // onto this prototype
      myProto = this.entityPrototype
      otherProto = otherT.entityPrototype
      for elem k in getAllPrototypeKeys(otherProto):
        if k != "constructor" and (not this.nativeProperties[k]):
          desc = getPropertyDescriptorFromPrototypeChain(otherProto, k)
          if desc: Object.defineProperty(myProto, k, desc)

    freezeNativeProperties(): void ->
      Object.assign(this.nativeProperties, {
        ...for elem k in Object.getOwnPropertyNames(this.entityPrototype):
          {[k]: true}
      })

    bootstrapFromPrototype(proto): void ->
      // Set demographic information
      proto.constructor~setType(this)
      this.entityPrototype = proto
      proto[fieldsSymbol] = this.fields

      // Compute JavaScript inheritance
      extendsProto = Object.getPrototypeOf(proto)
      extendsType = if extendsProto?.constructor: typeFrom(extendsProto.constructor)
      if extendsType:
        this.extendsPrototypically(extendsType)

    validate(x): boolean ->
      if x~looseEq(null): return true
      if typeof(x) != "object": return false
      Tx = x[typeSymbol] or x.constructor?[typeSymbol]
      Tx.isKindOf(this)

    createObservableGhost() ->
      throw new Error("entities without a driver cannot be observed")

    recurseLeft(left, state) ->
      memo = state.seen(left)
      if memo: return memo
      obj = state.create(this)
      state.remember(left, obj)
      left~forEachField! (k, v, spec): void -> state.visitField(obj, k, v, spec)
      obj

    recurseRight(left, right, state): void ->
      T = this
      state.remember(right, left)
      state.iterate(right, (k, v): void ->
        seen = state.seen(v)
        if T.fields[k]:
          state.visitCorrespondingField(left, T.fields[k], right, k, v, seen)
        else:
          state.visitUnknownField(left, right, k, v, seen)
      )
)

export ListType = singleton("ListType", ->
  class ListType extends ComplexType:
    constructor(name, elementType) ->
      super(name)
      this.elementType = elementType

    initialize(entity, spec, creator, initializer) ->
      creator(this)

    isKindOf(otherT): boolean ->
      (otherT instanceof ListType)
      and (this.elementType.isKindOf(otherT.elementType))

    validate(x): boolean ->
      x~looseEq(null) or (
        x[typeSymbol] and x[typeSymbol].isKindOf(this)
      )

    recurseLeft(left, state) ->
      T = this.elementType
      memo = state.seen(left)
      if memo: return memo
      obj = state.create(this)
      state.remember(left, obj)
      left.forEach! (v, i): void -> state.visitListEntry(obj, i, v, T)
      obj

    recurseRight(left, right, state): void ->
      T = this.elementType
      state.remember(right, left)
      if typeof(right.forEach) != "function":
        throw new Error("ListType.recurseRight: rhs wasn't an array or list. This is most likely caused by using assignPlainObject on an object with a list key, but a non-list value.")
      right.forEach! (v, i): void ->
        seen = state.seen(v)
        state.visitListEntry(left, T, right, i, v, seen)
)

export MapType = singleton("MapType", ->
  class MapType extends ComplexType:
    constructor(keyType, valueType) ->
      super()
      this.keyType = keyType
      this.valueType = valueType
)

export typeFrom(x) ->
  x[typeSymbol]

export isType(x) ->
  t = typeof x
  (t == "function" or t == "object") and (x[typeSymbol] instanceof Type)

export setType(x, T) ->
  x[typeSymbol] = T

listOfSymbol = Symbol.for("ephraim.listOfType")
export listOf(T) ->
  now T = typeFrom(T)
  if T[listOfSymbol]: return T[listOfSymbol]
  T[listOfSymbol] = new ListType(`listOf(${T.name})`, T)

mapOfSymbol = Symbol.for("ephraim.mapOfType")
export mapOf(T1, T2) ->
  now T1 = typeFrom(T1)
  now T2 = typeFrom(T2)
  cached = T1[mapOfSymbol]?[T2.typeIdentity]
  if cached: return cached
  // No cached map type, create
  T1[mapOfSymbol] = T1[mapOfSymbol] or {}
  T1[mapOfSymbol][T2.typeIdentity] = new MapType(T1, T2)

// Determine if x is-a instance of Type.
export isa(x, T): boolean ->
  now T = T[typeSymbol]
  if T: T.validate(x) else: false

// Determine if a Type is a kindOf anotherType
export isKindOf(T1, T2): boolean ->
  now T1 = T1[typeSymbol]
  now T2 = T2[typeSymbol]
  if T1: T1.isKindOf(T2) else: false
