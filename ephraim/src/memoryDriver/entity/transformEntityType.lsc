import { PrimitiveType, OpaqueType, underlyingTypeSymbol } from '../../types/type'
import { EntityType } from '../../types/entityType'
import { declaredFields, dataSymbol, rawSetSymbol } from '../../fields'
import { clearDeltaSymbol, fieldHasChangedSymbol, getChangedFieldKeysSymbol, hasChangesSymbol, getPreviousValueSymbol, setPreviousValueSymbol } from '../../delta'

import { definePrimitiveField } from './definePrimitiveField'
import { defineEntityField } from './defineEntityField'
import { getObservableEntityGhostClass } from './observable'
import { transformType } from '../transformType'
import { rawSet as deltaRawSet, clearDelta, setPreviousValue, getPreviousValue, getChangedFieldKeys, hasChanges, fieldHasChanged, createCloneCache } from './delta'

rawSet(k, v): void -> this[dataSymbol][k] = v

class MemoryEntityType extends EntityType:
  definePrimitiveField(key, spec): void ->
    definePrimitiveField(this.entityPrototype, spec.type, key, spec, false)

  defineOpaqueField(key, spec): void ->
    definePrimitiveField(this.entityPrototype, spec.type, key, spec, false)

  fieldOfTypeWasDefined(targetType, key, spec): void ->
    defineEntityField(targetType.entityPrototype, spec.type, key, spec, false)

  construct() -> new (this.entityConstructor)()

  bootstrapFromPrototype(proto): void ->
    super.bootstrapFromPrototype(proto)
    proto[rawSetSymbol] = rawSet

  createObservableGhost(entity) ->
    new (this~getObservableEntityGhostClass!)(entity)

class DeltaMemoryEntityType extends EntityType:
  definePrimitiveField(key, spec): void ->
    definePrimitiveField(this.entityPrototype, spec.type, key, spec, true)

  defineOpaqueField(key, spec): void ->
    definePrimitiveField(this.entityPrototype, spec.type, key, spec, true)

  fieldOfTypeWasDefined(targetType, key, spec): void ->
    defineEntityField(targetType.entityPrototype, spec.type, key, spec, true)

  bootstrapFromPrototype(proto): void ->
    super.bootstrapFromPrototype(proto)
    proto[rawSetSymbol] = deltaRawSet
    proto[clearDeltaSymbol] = clearDelta
    proto[fieldHasChangedSymbol] = fieldHasChanged
    proto[getChangedFieldKeysSymbol] = getChangedFieldKeys
    proto[hasChangesSymbol] = hasChanges
    proto[getPreviousValueSymbol] = getPreviousValue
    proto[setPreviousValueSymbol] = setPreviousValue

  construct() -> new (this.entityConstructor)()

  createObservableGhost(entity) ->
    new (this~getObservableEntityGhostClass!)(entity)

export transformEntityType(ET, transformedTypeSymbol, transformedTypeQualifier, isObservable, isDelta) ->
  typeClass = if isDelta: DeltaMemoryEntityType else: MemoryEntityType
  needsCloneCache = Boolean(isDelta and (Object.keys(ET.opaqueFields).length > 0))

  // Create ES2015 constructor for memory entity
  typeName = `${transformedTypeQualifier}(${ET.name})`
  EClass = ET.entityConstructor

  MemoryEntityClass(...args) ->
    obj = Object.create(MemoryEntityClass.prototype)
    obj[dataSymbol] = Object.create(null)
    if needsCloneCache: obj~createCloneCache()
    EClass.apply(obj, args)
    return obj

  MemoryEntityClass.prototype = Object.create(EClass.prototype, {
    constructor: {
      value: MemoryEntityClass
      enumerable: false
      writable: true
      configurable: true
    }
  })
  Object.setPrototypeOf(MemoryEntityClass, EClass)
  Object.defineProperty(MemoryEntityClass, "name", { value: typeName })

  // Create ephraim type for memory entity; associate it with prototype
  MT = new typeClass(typeName)
  MT.bootstrapFromPrototype(MemoryEntityClass.prototype)
  MT.setEntityConstructor(MemoryEntityClass)

  // Cache newly created types to prevent cycles/recursion
  ET[transformedTypeSymbol] = MT
  MT[transformedTypeSymbol] = MT
  MT[underlyingTypeSymbol] = ET

  // Update field types; each field type must be memory(previousType)
  nextFields = {
    ...for key k, val spec in MemoryEntityClass~declaredFields():
      nextSpec = Object.assign({}, spec)
      if not ((nextSpec.type instanceof PrimitiveType) or (nextSpec.type instanceof OpaqueType)):
        nextSpec.type = transformType(nextSpec.type, isDelta)
      {[k]: nextSpec}
  }
  // Apply field definitions
  for key k, val spec in nextFields: MT.defineField(k, spec)

  MT
