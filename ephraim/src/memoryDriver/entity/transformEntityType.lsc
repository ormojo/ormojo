import { EntityType, PrimitiveType, underlyingTypeSymbol } from '../../type'
import { declaredFields, dataSymbol } from '../../fields'
import { deltaSymbol, isDeltaSymbol } from '../../delta'

import { definePrimitiveField } from './definePrimitiveField'
import { defineEntityField } from './defineEntityField'
import { getObservableEntityGhostClass } from './observable'
import { transformType } from '../transformType'

hasOwnProperty = Object.prototype.hasOwnProperty

class MemoryEntityType extends EntityType {
  definePrimitiveField(key, spec): void ->
    definePrimitiveField(this.entityPrototype, spec.type, key, spec, false)

  fieldOfTypeWasDefined(targetType, key, spec): void ->
    defineEntityField(targetType.entityPrototype, spec.type, key, spec, false)

  construct() -> new (this.entityConstructor)()

  rawSet(entity, fieldKey, val) ->
    entity[dataSymbol][fieldKey] = val

  createObservableGhost(entity) ->
    new (this~getObservableEntityGhostClass!)(entity)
} // class MemoryEntityType

class DeltaMemoryEntityType extends EntityType {
  definePrimitiveField(key, spec): void ->
    definePrimitiveField(this.entityPrototype, spec.type, key, spec, true)

  fieldOfTypeWasDefined(targetType, key, spec): void ->
    defineEntityField(targetType.entityPrototype, spec.type, key, spec, true)

  bootstrapFromPrototype(proto): void ->
    super.bootstrapFromPrototype(proto)
    proto[isDeltaSymbol] = true

  rawSet(entity,fieldKey, val) ->
    entity[dataSymbol][fieldKey] = val

  clearDelta(entity): void ->
    entity[deltaSymbol] = Object.create(null)

  flushDelta(entity): void ->
    delta = entity[deltaSymbol]
    if not delta: return
    data = entity[dataSymbol] or Object.create(null)
    for key k, val v in delta: data[k] = v
    entity[dataSymbol] = data
    entity[deltaSymbol] = Object.create(null)

  getChangedFields(entity): Array<string> ->
    delta = entity[deltaSymbol]
    if delta: Object.keys(delta) else: null

  hasChanges(entity): boolean ->
    delta = entity[deltaSymbol]
    if delta: Object.keys(delta).length > 0 else: false

  fieldHasChanged(entity, field): boolean ->
    delta = entity[deltaSymbol]
    if delta and hasOwnProperty.call(delta, field): true else: false

  construct() -> new (this.entityConstructor)()

  createObservableGhost(entity) ->
    new (this~getObservableEntityGhostClass!)(entity)
} // class MemoryEntityType

export transformEntityType(ET, transformedTypeSymbol, transformedTypeQualifier, isObservable, isDelta) ->
  typeClass = if isDelta: DeltaMemoryEntityType else: MemoryEntityType

  // Create ES2015 constructor for memory entity
  typeName = `${transformedTypeQualifier}(${ET.name})`
  EClass = ET.entityConstructor
  class MemoryEntityClass extends EClass {}
  Object.defineProperty(MemoryEntityClass, "name", { value: typeName })

  // Create ephraim type for memory entity; associate it with prototype
  MT = new typeClass(typeName)
  MT.bootstrapFromPrototype(MemoryEntityClass.prototype)

  // Discard ES2015 constructor in favor of a simpler vanilla JS constructor
  memoryEntityClass = (): void ->
    this[dataSymbol] = Object.create(null)
  // Set constructor name to typename
  Object.defineProperty(memoryEntityClass, "name", { value: MT.name })
  memoryEntityClass.prototype = MemoryEntityClass.prototype
  MT.setEntityConstructor(memoryEntityClass)

  // Cache newly created types to prevent cycles/recursion
  ET[transformedTypeSymbol] = MT
  MT[transformedTypeSymbol] = MT
  MT[underlyingTypeSymbol] = ET

  // Update field types; each field type must be memory(previousType)
  nextFields = {
    ...for key k, val spec in memoryEntityClass~declaredFields():
      nextSpec = Object.assign({}, spec)
      if not (nextSpec.type instanceof PrimitiveType):
        nextSpec.type = transformType(nextSpec.type, isDelta)
      {[k]: nextSpec}
  }
  // Apply field definitions
  for key k, val spec in nextFields: MT.defineField(k, spec)

  MT
