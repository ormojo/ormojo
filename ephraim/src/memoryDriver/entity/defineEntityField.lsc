import { deltaSymbol } from '../../delta'
import { dataSymbol } from '../../fields'
import { typeCheckAssignment } from '../../util'
import { observedFieldsSymbol } from '../../observe'

createGetterMethod(proto, type, key) ->
  () -> this[dataSymbol][key]

createDeltaSetterMethod(proto, type, key) ->
  (val): void ->
    curVal = this[dataSymbol][key]
    if val == curVal: return
    typeCheckAssignment(type, key, val)
    this[dataSymbol][key] = val

    let delta = this[deltaSymbol]
    if not delta: this[deltaSymbol] = now delta = Object.create(null)
    delta[key] = val

    observedFields = this[observedFieldsSymbol]
    if observedFields:
      observedFields[key]?.next(this)
      observedFields._all_?.next({entity: this, key})

createNonDeltaSetterMethod(proto, type, key) ->
  (val): void ->
    curVal = this[dataSymbol][key]
    if val == curVal: return
    typeCheckAssignment(type, key, val)
    this[dataSymbol][key] = val

    observedFields = this[observedFieldsSymbol]
    if observedFields:
      observedFields[key]?.next(this)
      observedFields._all_?.next({entity: this, key})

createSetterMethod(proto, type, key, isDelta) ->
  if isDelta:
    createDeltaSetterMethod(proto, type, key)
  else:
    createNonDeltaSetterMethod(proto, type, key)

export defineEntityField(proto, type, key, spec, isDelta) ->
  Object.defineProperty(proto, key, {
    configurable: true
    enumerable: true
    get: createGetterMethod(proto, type, key, spec)
    set: createSetterMethod(proto, type, key, spec, isDelta)
  })
