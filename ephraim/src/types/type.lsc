import { singleton } from '../singleton'

export typeSymbol = Symbol.for("ephraim.type")
export underlyingTypeSymbol = Symbol.for("ephraim.underlyingType")

export Type = singleton("Type", ->
  class Type:
    constructor(name) ->
      this[typeSymbol] = this
      this.extra = {}
      this.name = name
      this.typeIdentity = Symbol(name)

    extends(otherT): void ->
      this.extra = Object.assign({}, otherT?.extra)

    isKindOf(otherT): boolean ->
      otherT == this

    // Check that x is an instance of this type
    // eslint-disable-next-line no-unused-vars
    validate(x): boolean ->
      false

    // Called when a field of this type was defined on an EntityType.
    // Used to set up the `defineProperty` hooks, et al.
    // eslint-disable-next-line no-unused-vars
    fieldOfTypeWasDefined(defineeType, key, spec): void ->
      return

    // Descend into this object recursively
    recurseLeft(left) -> left

    // Descend into another object recursively, mapping it onto this object
    // eslint-disable-next-line no-unused-vars
    recurseRight(left, right): void -> return

    // Set type extra data. This is inherited (via Object.assign) when a new
    // type is created based on this one.
    setExtra(key, value) -> this.extra[key] = value

    // Get type extra data
    getExtra(key) -> this.extra[key]

    // Function called when the user attempts to create an observable version
    // of an object of this type.
    createObservableGhost() ->
      throw new Error(`Type '${this.name}' does not define an observable interface`)
)

export PrimitiveType = singleton("PrimitiveType", ->
  class PrimitiveType extends Type:
    constructor(name) ->
      super(name)

    createObservableGhost() ->
      throw new Error("primitive types cannot be observed")

    initialize(entity, spec, creator, initializer) ->
      initializer.call(entity)
)

export OpaqueType = singleton("OpaqueType", ->
  class OpaqueType extends Type:
    constructor(name) ->
      super(name)

    createObservableGhost() ->
      throw new Error("primitive types cannot be observed")

    initialize(entity, spec, creator, initializer) ->
      initializer.call(entity)
)

export ComplexType = singleton("ComplexType", ->
  class ComplexType extends Type:
    constructor(name) ->
      super(name)
      this.isa = { [this.typeIdentity]: true }

    extends(otherT): void ->
      if not (otherT instanceof ComplexType):
        throw new Error(`Invalid inheritance: complex type '${this.name}' cannot extend non-complex type '${otherT.name}'`)
      super.extends(otherT)
      for elem sym in Object.getOwnPropertySymbols(otherT.isa):
        this.isa[sym] = true

    isKindOf(otherT): boolean ->
      otherTypeIdentity = otherT.typeIdentity
      if otherTypeIdentity and this.isa[otherTypeIdentity]: true else: false
)

export typeFrom(x) ->
  x[typeSymbol]

export isType(x) ->
  t = typeof x
  (t == "function" or t == "object") and (x[typeSymbol] instanceof Type)

// Convert a type into user-consumable form
export consumableType(T) ->
  EC = T.entityConstructor
  if EC: EC else: T

export isPrimitiveType(T) ->
  T[typeSymbol] instanceof PrimitiveType

export setType(x, T) ->
  x[typeSymbol] = T

// Determine if x is-a instance of Type.
export isa(x, T): boolean ->
  now T = T[typeSymbol]
  if T: T.validate(x) else: false

// Determine if a Type is a kindOf anotherType
export isKindOf(T1, T2): boolean ->
  now T1 = T1[typeSymbol]
  now T2 = T2[typeSymbol]
  if T1: T1.isKindOf(T2) else: false

// Determine the underlying type of a type.
export underlyingTypeOfType(T) ->
  now T = typeFrom(T)
  UT = T[underlyingTypeSymbol]
  if UT: UT~consumableType() else: T
