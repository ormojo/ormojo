import { createBehaviorSubject } from '@ormojo/fobs'
import { $DATA, $INTEREST, $TYPEOF } from './symbols'
import { Store } from './Store'
import { debug } from './debug'

isEmpty(obj) ->
  for val v in obj: if v~looseNotEq(null): return false
  true

// eslint-disable-next-line no-unused-vars
createGetter(proto, type, key) ->
  const DATA = $DATA
  () -> this[DATA][key]

// eslint-disable-next-line no-unused-vars
createSetter(proto, type, key) ->
  const DATA = $DATA, INTEREST = $INTEREST
  (val): void ->
    if this[DATA][key] == val: return
    this[DATA][key] = val

    // Notify interested parties of key changes
    interest = this[INTEREST]
    if interest:
      observation = { key, value: val, record: this }
      interest[key]?.next(observation)
      interest._shallow?.next(observation)
      interest._deep?.next(observation)

observeLocalKey(key) ->
  record = this
  interest = record[$INTEREST] ||= {}
  if interest[key]: return interest[key]

  observable = createBehaviorSubject({
    onObserversChanged(observers, added, removed): void ->
      // If we removed the last observer
      if removed and observers.length == 0:
        // Clear us from the interested fields list
        interest[key] = undefined
        // If interested list is empty, eliminate it
        if interest~isEmpty(): record[$INTEREST] = undefined
  })

  // Prime behavior subject with initial value
  observable.next({ key, value: record[key], record })

  interest[key] = observable

initializeModel(record, key, attr, store) ->
  val = try:
    store.createRaw(attr.type.name)
  catch err:
    // Clarify error on key creation
    throw new Error(`Error while instantiating '${key}' of type '${attr.type.name}' on record of type '${record[$TYPEOF].name}': `+ err.message)

  init = attr.initializer
  if typeof(init) == 'function':
    init.call(record, val)
  val._initialize()
  val

initializeValue(attr) ->
  init = attr.initializer
  if typeof(init) == 'function':
    init()
  else:
    attr.type.clone(init)

export class MemoryStore extends Store:
  _applyProperty(boundModel, prop, type): void ->
    debug("MemoryStore._applyProperty", boundModel.name, '[', prop.key, ']:', type.name)
    proto = boundModel.prototype
    key = prop.key
    Object.defineProperty(proto, key, {
      configurable: false
      enumerable: true
      get: createGetter(proto, type, key)
      set: createSetter(proto, type, key)
    })

  // eslint-disable-next-line no-unused-vars
  _createBoundModel(name, model, opts) ->
    store = this

    model.extend(name, {
      _construct(): void ->
        super._construct()
        this[$DATA] = {}

      _initialize(): void ->
        super._initialize()
        for key k, val attr in model.attributes:
          if this[k] == undefined and attr.hasInitializer():
            if attr.type.isModel():
              this[k] = initializeModel(this, k, attr, store)
            else:
              this[k] = initializeValue(attr)

      observe: observeLocalKey
    })

  createRaw(type) ->
    model = this.models.get(type)
    if not model:
      throw new Error(`No model named ${type} is bound to this store`)
    new model()

  new(type) ->
    record = this.createRaw(type)
    record._initialize()
    record
