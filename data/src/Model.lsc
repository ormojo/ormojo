import { Type } from './Type'
import { Property } from './Property'
import { $MODEL_TYPE } from './symbols'

export class Model extends Type:
  static [$MODEL_TYPE] = true
  static properties = {}
  // Attributes are properties that have independent, stored values, i.e.
  // not computed or private properties.
  static attributes = {}

  // Assign model-specific qualities of this model to another
  static _assignTo(nextModel): void ->
    nextModel.properties = {}
    nextModel.attributes = {}

    for key k, val v in this.properties:
      cloned = v.clone()
      cloned.setModel(nextModel)
      nextModel.properties[k] = cloned
      if cloned.isAttribute():
        nextModel.attributes[k] = cloned

  // Define attribute on this model
  static _defineProperty(key, def): void ->
    this.properties[key] = def
    if def.isAttribute(): this.attributes[key] = def
    def.setKey(key)
    def.setModel(this)

  static extend(name, def) ->
    if typeof(name) != 'string':
      throw new Error(`${this.name}.extend: a string name is required`)
    extension = class extends this {}
    Object.defineProperty(extension, "name", { value: name })
    // This makes es6 super calls work for methods defined on the `def` argument
    Object.setPrototypeOf(def, this.prototype)
    this._assignTo(extension)
    for key k, val v in def:
      if Property.isProperty(v):
        extension._defineProperty(k, v)
      else:
        extension.prototype[k] = v

    extension

  // Create a new empty instance
  constructor() ->
    super()
    this._construct()

  // Overridable subclass constructor
  _construct() ->
    return

  // Apply default values to all properties that don't have them
  _initialize() ->
    return

  // Get the model associated with an instance
  getModel() ->
    this.constructor

  // Get all properties of the defining model as a hash {[name]: Property}
  getProperties() ->
    this.constructor.properties
