import { Backend, setBackend, getBackend, normalizeLoggerObject } from '@ormojo/ormojo'
import { ESIndices } from './indices'
import { ESMigration } from './migration'
import { makeESAPI } from './makeESAPI'
import { ESQuery } from './query'
import { typeFrom, createMemory as create, assignPlainObject } from '@ormojo/ephraim'
import { getIndexForType, getESTypeForType } from './util'
import { ESSink } from './bulkSink'
import { ESSource } from './source'

export class ESBackend extends Backend:
  constructor(es, opts) ->
    super()
    this.es = es
    this.log = normalizeLoggerObject(opts?.log)
    this.api = makeESAPI(this.es, this.log)
    this.indices = new ESIndices(this)
    this.typeMap = new Map()
    this.sink = new ESSink({es: this.es, log: this.log })
    // Source constructor
    typeMap(idx, ty) => this.indices.getEphraimTypeForESType(idx, ty)
    this.source = new ESSource({es: this.es, log: this.log, typeMap, defaultType: null, errorOnMissingType: true})
    if opts?.indexPrefix: this.indexPrefix = opts.indexPrefix

  registerType(T): void ->
    now T = typeFrom(T)
    if T~getBackend():
      throw new Error(`ESBackend.registerType(): Type ${T.name} was previously registered with another backend. To register with this backend, create a subclass.`)
    idx = getIndexForType(T)
    est = getESTypeForType(T)
    if not idx:
      throw new Error(`ESBackend.registerType(): Type ${T.name} was registered without an Elasticsearch index set.`)
    if not est:
      throw new Error(`ESBackend.registerType(): Type ${T.name} was registered without an Elasticsearch type set.`)
    T~setBackend(this)
    this.typeMap.set(T, true)
    this.indices.addEntityType(T)

  getMigration() ->
    new ESMigration(this)

  createQuery(): ESQuery ->
    new ESQuery(this)

  create(type, data, opts) ->
    instance = create(type)
    instance._isNewRecord = true
    instance._index = getIndexForType(type)
    instance._type = getESTypeForType(type)
    if data~looseNotEq(null):
      instance~assignPlainObject(data)
      this.save(instance, opts)
    else:
      instance

  save(instance, opts) ->
    { sink } = this
    if instance._isNewRecord:
      sink.create([instance], opts).then! -> instance
    else:
      sink.upsert([instance], opts).then! -> instance

  destroy(instance, opts) ->
    { sink } = this
    sink.delete([instance], opts).then! (rst) ->
      if rst?.results[0]: instance._wasDeleted = true
      instance

  destroyById(type, id, opts) ->
    target = {
      _id: id
      _type: getESTypeForType(type)
      _index: getIndexForType(type)
    }
    if opts?.parent: target._parent = opts.parent
    this.sink.delete([target]).then! rst -> rst?.results[0]

  find(query) ->
    this.source.read(query)
