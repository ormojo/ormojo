import { Migration } from '@ormojo/ormojo'
import isEqual from 'lodash/isEqual'
import deepDiff from 'deep-diff'
import set from 'lodash/set'

_getMigrationCounter(indexList) ->
  let maxn = 0
  for elem index in indexList:
    mtch = /_v(\d+)$/.exec(index)
    // Unmigrated indices in the alias = bailout.
    if not mtch: return null
    n = parseInt(mtch[1])
    if n > maxn: now maxn = n
  maxn

//
// Migration plan for a specific index. Determines if the index can
// be migrated and how.
//
class MigrationPlan:
  constructor(backend, index) ->
    this.backend = backend
    this.index = index

    analysis = {}
    if index.analyzer: analysis.analyzer = index.analyzer
    if index.filter: analysis.filter = index.filter

    settings = { analysis }
    if index.settings: Object.assign(settings, index.settings)

    this.targetSettings = {
      mappings: this.index.mappings
      settings: { analysis }
    }

  getTargetSettings() -> this.targetSettings

  prepare() ->
    this.getIndex()
      .then(=> this.finalChecks())

  getIndex() ->
    this.indexStatus = 'UNKNOWN'
    this.backend.es.indices.get({index: this.index.name}, { ignore: [404] })
      .then((result) =>
        // Check for missing index.
        if result.error:
          if result.status == 404: this.indexStatus = 'DOESNT_EXIST'
          return
        // Check for unaliased index which can't be migrated
        if result[this.index.name]:
          this.indexStatus = 'NOT_ALIASED'
          return
        // Check for highest-numbered automigrated index
        matchingIndices = [...for key k in result: [k]]
        n = _getMigrationCounter(matchingIndices)
        if n == null:
          this.indexStatus = 'NOT_MIGRATED'
          return
        else:
          this.indexStatus = 'AUTOMIGRATED'
          this.migrationCounter = n
          this.mostRecentIndex = `${this.index.name}_v${n}`
        // Get details of most recent index
        details = result[this.mostRecentIndex]
        this.currentSettings = {
          mappings: details.mappings
          settings: {
            analysis: details.settings?.index?.analysis or {}
          }
        }
      )

  finalChecks() ->
    if this.indexStatus == 'DOESNT_EXIST':
      this.migrationStrategy = 'CREATE'
      return

    this.backend.log.trace('elasticsearch: computing migration diff', this.currentSettings, this.targetSettings)

    // If mappings are the same, migration is unnecessary.
    if isEqual(this.currentSettings, this.targetSettings):
      this.backend.log.trace('elasticsearch: no difference, migration not needed')
      this.migrationStrategy = 'NOT_NEEDED'
      return

    this.migrationDiff = deepDiff.diff(this.currentSettings, this.targetSettings)

    // Patch up white noise in migration diff
    for elem difference in this.migrationDiff:
      // Elasticsearch annoyingly stringifies numbers. We must do the same.
      if difference.kind == 'E' and (JSON.stringify(difference.rhs) == difference.lhs):
        set(this.targetSettings, difference.path, difference.lhs)

      // Elasticsearch omits date formats when returning index data.
      if difference.kind == 'N' and (difference.path[difference.path.length - 1] == 'format'):
        set(this.currentSettings, difference.path, difference.rhs)

    if isEqual(this.currentSettings, this.targetSettings):
      this.backend.log.trace('elasticsearch: no difference, migration not needed')
      this.migrationStrategy = 'NOT_NEEDED'
      return

    this.backend.log.trace('elasticsearch: diff', this.migrationDiff)

    // Determine a migration strategy.
    this.migrationStrategy = 'CANT_MIGRATE'
    if this.indexStatus == 'UNKNOWN' or this.indexStatus == 'NOT_ALIASED' or this.indexStatus == 'NOT_MIGRATED':
      this.reason = 'Index cannot be automigrated.'
    else if this.indexStatus == 'AUTOMIGRATED':
      this.migrationStrategy = 'REINDEX'

    this

  executeCreateStrategy() ->
    if this.migrationStrategy != 'CREATE': throw new Error('executeCreateStrategy() called in invalid state')
    aliases = {}
    aliases[this.index.name] = {}
    body = Object.assign({}, this.targetSettings, { aliases })
    Promise.resolve(
      this.backend.es.indices.create({
        index: `${this.index.name}_v1`
        body
      })
    )
      .then(({body: result}) =>
        this.backend.log.trace('es.indices.create <', result)
        result
      )

  executeReindexStrategy() ->
    if this.migrationStrategy != 'REINDEX': throw new Error('executeReindexStrategy() called in invalid state')
    prevIndex = `${this.index.name}_v${this.migrationCounter}`
    nextIndex = `${this.index.name}_v${this.migrationCounter + 1}`
    alias = `${this.index.name}`
    Promise.resolve(
      this.backend.es.indices.create({
        index: nextIndex
        body: this.targetSettings
      })
    ).then(=>
      this.backend.es.indices.flush({ index: prevIndex })
    ).then(=>
      this.backend.es.reindex({
        waitForCompletion: true
        body: {
          source: { index: prevIndex }
          dest: { index: nextIndex, op_type: 'create' }
        }
      })
    ).then(=>
      this.backend.es.indices.updateAliases({
        body: {
          actions: [
            { remove: { index: prevIndex, alias } }
            { add: { index: nextIndex, alias} }
          ]
        }
      })
    )

  execute() ->
    if this.migrationStrategy == 'REINDEX':
      this.executeReindexStrategy()
    else if this.migrationStrategy == 'CREATE':
      this.executeCreateStrategy()
    else if (not this.migrationStrategy):
      Promise.reject(new Error('unprepared MigrationPlan'))
    else:
      Promise.resolve()

export class ESMigration extends Migration:
  constructor(backend) ->
    super(backend)
    this.plans = {}
    for key name, val index in this.backend.indices.getIndices():
      this.plans[name] = new MigrationPlan(backend, index)

  prepare() ->
    // Develop a migration plan for each index.
    promises = [...for val plan in this.plans: [plan.prepare()]]
    Promise.all(promises).then(=> this)

  getMigrationPlan() ->
    [...for val plan in this.plans:
      [{
        strategy: plan.migrationStrategy
        index: plan.index.name
        currentSettings: plan.currentSettings
        targetSettings: plan.targetSettings
        settingsDiff: plan.migrationDiff
      }]
    ]

  execute() ->
    promises = [...for val plan in this.plans: [plan.execute()]]
    Promise.all(promises)
