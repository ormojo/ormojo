import { Migration, MigrationPart } from '@ormojo/ormojo'
import { isEqual, last, isEmpty } from 'lodash'
import deepDiff from 'deep-diff'

parseVersion(physicalIndexName) ->
  mtch = /_(\d+)$/.exec(physicalIndexName)
  if mtch: parseInt(mtch[1]) else: null

// Indices that are ignored
incomparableIndexSettings = [
  'provided_name'
  'creation_date'
  'uuid'
  'version'
]

isShardingParameterDiff(difference) ->
  match last(difference.path):
    | 'number_of_shards': true
    | 'number_of_replicas': true
    | else: false

// Determine if a difference in index settings is relevant during migration
isRelevantDifference(difference) ->
  // Elasticsearch stringifies numbers, causing false positives
  if difference.kind == 'E' and (JSON.stringify(difference.rhs) == difference.lhs):
    return false

  // Elasticsearch doesn't return date formats when inquiring about index
  // settings. This may cause false positives.
  if difference.kind == 'N' and (last(difference.path) == 'format'):
    return false

  // If the user didn't specify sharding or replication parameters, we
  // don't need to diff them
  if difference.kind == 'D' and isShardingParameterDiff(difference):
    return false

  // An empty, new, analysis setting is irrelevant
  if difference.kind == 'N'
    and isEqual(difference.path, ['settings', 'analysis'])
    and isEmpty(difference.rhs):
      return false

  true

//
// Migration plan for a specific index. Determines if the index can
// be migrated and how.
//
class ESMigrationPart extends MigrationPart:
  constructor(index) ->
    this.index = index
    this.indexStatus = 'UNKNOWN'
    this.migrationStrategy = 'UNKNOWN'

    analysis = {}
    if index.analyzer: analysis.analyzer = index.analyzer
    if index.filter: analysis.filter = index.filter

    settings = { analysis }
    if index.settings: Object.assign(settings, index.settings)

    this.targetSettings = {
      mappings: index.mappings
      settings: { analysis }
    }

  getTargetSettings() -> this.targetSettings

  prepare(context) -/>
    <- this.getExistingAlias(context)
    <- this.planIndexTransition(context)

  // See if the desired index has an existing alias.
  getExistingAlias({ es }): void -/>
    aliasName = this.index.name

    result <- es.indices.get({index: aliasName}, {ignore:[404]})

    // If no alias, it's safe to create one
    if (result.error) and (result.status == 404):
      this.indexStatus = 'DOESNT_EXIST'
      return

    // If a raw index with this name exists, we can't do a migration.
    if result[aliasName]:
      this.indexStatus = "NOT_ALIASED"
      return

    // If alias exists, locate the "best" physical backing index. If some
    // particular index is labeled as the write index, we always use that.
    // Otherwise use the index with the newest creation date
    let newestVersion = 0
    let newestTimestamp = 0
    let writeIndex = null
    let newestIndex = null
    for key physicalIndexName, val descriptor in result:
      version = parseVersion(physicalIndexName)
      if version != null and version > newestVersion:
        now newestVersion = version

      if descriptor.aliases[aliasName]?.is_write_index:
        now writeIndex = physicalIndexName

      timestamp = parseInt(descriptor.settings?.index?.creation_date or '0')
      if timestamp > newestTimestamp:
        now newestTimestamp = timestamp
        now newestIndex = physicalIndexName

    this.previousWriteIndex = writeIndex
    bestIndex = writeIndex or newestIndex
    this.nextVersion = newestVersion + 1

    // An alias with no indices at all?
    if not bestIndex:
      throw new Error(`Could not find bestIndex for alias '${aliasName}'`)

    // We have a current best index, so there is potential for migration.
    // Determine the settings we need to compare against to determine if
    // migration is needed
    this.indexStatus = 'MIGRATABLE'
    this.currentIndex = bestIndex
    details = result[bestIndex]
    this.currentIndexDetails = details

    settings = Object.assign({}, details.settings?.index)
    for elem k in incomparableIndexSettings: delete settings[k]

    this.currentSettings = {
      mappings: details.mappings
      settings
    }


  planIndexTransition({ log }): void ->
    this.migrationStrategy = 'CANT_MIGRATE'

    // If the index doesn't exist, create it
    if this.indexStatus == 'DOESNT_EXIST':
      log.trace('elasticsearch: migration target index missing, will create')
      this.migrationStrategy = 'ADD_PHYSICAL_INDEX'
      return

    // If the index is a hard index, we can't migrate
    if this.indexStatus == 'NOT_ALIASED':
      this.migrationStrategy = 'CANT_MIGRATE'
      this.reason = 'Target index is a physical index that cannot be aliased.'
      return

    log.trace('elasticsearch: computing migration diff', this.currentSettings, this.targetSettings)

    // If mappings are the same, migration is unnecessary.
    if isEqual(this.currentSettings, this.targetSettings):
      log.trace('elasticsearch: no difference, migration not needed')
      this.migrationStrategy = 'NOT_NEEDED'
      return

    this.migrationDiff = deepDiff.diff(this.currentSettings, this.targetSettings)

    // Patch up white noise in migration diff
    this.relevantDiffs = [...for elem difference in this.migrationDiff:
      if isRelevantDifference(difference): [difference]
    ]

    if this.relevantDiffs.length == 0:
      log.trace('elasticsearch: no relevant differences in index settings, migration not needed')
      this.migrationStrategy = 'NOT_NEEDED'
      return

    log.trace('elasticsearch: diff', this.relevantDiffs)

    if this.indexStatus == 'MIGRATABLE':
      this.migrationStrategy = 'ADD_PHYSICAL_INDEX'


  executeCreateStrategy({ es, log }): void -/>
    if this.migrationStrategy != 'ADD_PHYSICAL_INDEX':
      throw new Error('executeCreateStrategy() called in invalid state')

    // Create the new index
    log.trace('creating new physical index')
    newPhysicalIndexName = `${this.index.name}_${this.nextVersion or 1}`
    aliases = {
      [this.index.name]: {}
    }
    body = Object.assign({}, this.targetSettings, { aliases })
    <- es.indices.create({
      index: newPhysicalIndexName
      body
    })

    // Atomically swap new index as write index
    log.trace('performing atomic write index swap')
    actions = [{
      "add": {
        "index": newPhysicalIndexName
        "alias": this.index.name
        "is_write_index": true
      }
    }]
    if this.previousWriteIndex:
      actions.push({
        "add": {
          "index": this.previousWriteIndex
          "alias": this.index.name
          "is_write_index": false
        }
      })
    <- es.indices.updateAliases({ body: { actions} })

  execute(context) ->
    if this.migrationStrategy == 'ADD_PHYSICAL_INDEX':
      this.executeCreateStrategy(context)
    else if (not this.migrationStrategy):
      Promise.reject(new Error('unprepared MigrationPlan'))
    else:
      Promise.resolve()

  toJSON() -> {
    migrationStrategy: this.migrationStrategy
    indexName: this.index.name
    currentSettings: this.currentSettings
    targetSettings: this.targetSettings
    diff: this.relevantDiffs
  }

  isActionNeeded() ->
    if this.migrationStrategy == "ADD_PHYSICAL_INDEX":
      true
    else:
      false

export class ESMigration extends Migration:
  prepare() ->
    // Generate a migration part for each index
    this.parts = [...for val index in this.backend.indices.getIndices():
      [new ESMigrationPart(index)]
    ]

    context = {
      es: this.backend.es
      log: this.backend.log
    }

    // Develop a migration plan for each index.
    promises = [...for elem part in this.parts: [part.prepare(context)]]
    Promise.all(promises).then(=> this)

  execute() ->
    context = {
      es: this.backend.es
      log: this.backend.log
    }
    promises = [...for elem part in this.parts: [part.execute(context)]]
    Promise.all(promises)
