import { AsyncSource } from '@ormojo/ormojo'
import { ESQuery, ESResultSet, updateInstanceWithData } from './query'

export class ESSource extends AsyncSource:
  constructor(opts) ->
    super(opts)
    this.typeMap = opts.typeMap
    this.defaultType = opts.defaultType
    this.errorOnMissingType = opts.errorOnMissingType
    this.es = opts.es
    this.log = opts.log

  _get(query, id) ->
    // Elasticsearch GET
    { log, es, typeMap, defaultType, errorOnMissingType } = this
    rq = {
      id
      index: query.index
      type: query.type
      ignore: [404]
      ...if query.parent: { parent: query.parent }
    }
    log.trace("es.get >", rq)
    es.get(rq).then! (rst) ->
      log.trace("es.get <", rst)
      if rst.found:
        new ESResultSet([rst])._hydrate(typeMap, defaultType, errorOnMissingType)
      else:
        new ESResultSet([])

  _mget(query, ids) ->
    // Elasticsearch MGET
    { log, es, typeMap, defaultType, errorOnMissingType } = this
    rq = {
      index: query.index
      type: query.type
      body: { ids }
      ...if query.parent: { routing: query.parent }
    }
    log.trace("es.mget >", rq)
    es.mget(rq).then! (rst) ->
      log.trace("es.mget <", rst)
      docs = rst?.docs or []
      new ESResultSet([
        ...for elem doc in docs: if doc?.found: [doc] else: [undefined]
      ])._hydrate(typeMap, defaultType, errorOnMissingType)

  _find(query) ->
    { log, es, typeMap, defaultType, errorOnMissingType } = this
    rq = {
      body: query.getQueryDsl()
      version: true
      index: query.index
      type: query.type
      ...if query.offset: { from: query.offset }
      ...if query.limit: { size: query.limit }
    }
    log.trace("es.search >", rq)
    es.search(rq).then! (rst) ->
      log.trace("es.search <", rst)
      if (not rst) or (not rst.hits):
        new ESResultSet([], 0, 0, query, 0)
      else:
        new ESResultSet(rst.hits.hits, rst.hits.total, rq.from, query, rst.hits.max_score)._hydrate(typeMap, defaultType, errorOnMissingType)

  readIdQuery(query: ESQuery): Promise<ESResultSet> ->
    ids = query.ids
    if ids.length == 0:
      Promise.resolve(new ESResultSet([]))
    else if ids.length == 1:
      this._get(query, ids[0])
    else:
      this._mget(query, ids)

  readFullQuery(query: ESQuery): Promise<ESResultSet> ->
    this._find(query)

  read(query: ESQuery): Promise<ESResultSet> ->
    if query.ids:
      this.readIdQuery(query)
    else:
      this.readFullQuery(query)

export { updateInstanceWithData }
