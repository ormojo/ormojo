import { AsyncSource } from '@ormojo/ormojo'
import { ESQuery, ESResultSet } from './query'

export class ESSource extends AsyncSource:
  constructor(opts) ->
    super(opts)
    this.backend = opts.backend
    this.typeMap = opts.typeMap
    this.defaultType = opts.defaultType
    this.errorOnMissingType = opts.errorOnMissingType
    this.es = opts.es
    this.log = opts.log

  _get(query, id) -/>
    // Elasticsearch GET
    { es, typeMap, defaultType, errorOnMissingType, backend } = this
    rq = {
      id
      index: query.index
      stored_fields: 'orm_type'
      _source: true
    }
    rst <- es.get(rq, { ignore: [404] })
    if rst.found:
      new ESResultSet(backend, [rst])._hydrate(typeMap, defaultType, errorOnMissingType)
    else:
      new ESResultSet(backend, [])


  _mget(query, ids) -/>
    // Elasticsearch MGET
    { es, typeMap, defaultType, errorOnMissingType, backend } = this
    rq = {
      index: query.index
      stored_fields: 'orm_type'
      body: { ids }
      _source: true
    }
    rst <- es.mget(rq)
    docs = rst?.docs or []
    new ESResultSet(backend, [
      ...for elem doc in docs: if doc?.found: [doc] else: [undefined]
    ])._hydrate(typeMap, defaultType, errorOnMissingType)

  _find(query) -/>
    { es, typeMap, defaultType, errorOnMissingType, backend } = this
    rq = {
      body: query.getQueryDsl()
      seq_no_primary_term: true
      index: query.index
      _source: true
      ...if query.offset: { from: query.offset }
      ...if query.limit: { size: query.limit }
    }
    rst <- es.search(rq)
    if (not rst) or (not rst.hits):
      new ESResultSet(backend, [], 0, 0, query, 0)
    else:
      new ESResultSet(backend, rst.hits.hits, rst.hits.total.value, rq.from, query, rst.hits.max_score)._hydrate(typeMap, defaultType, errorOnMissingType)

  readIdQuery(query: ESQuery): Promise<ESResultSet> ->
    let ids = query.ids
    if ids.length == 0:
      return Promise.resolve(new ESResultSet(this.backend, []))
    if ids.length == 1:
      now ids = [ ids[0] ]

    idQuery = (new ESQuery()).setQuery(query)
    idQuery.body = {
      query: {
        ids: {
          values: ids
        }
      }
    }
    idQuery.limit = ids.length

    this._find(idQuery)
      .then((resultSet) ->
        idMap = { ...for elem e in resultSet.getResults(): {[e.id]: e} }
        nextResults = [ ...for elem id in ids: [idMap[id]] ]
        resultSet.replaceResults(nextResults)
        resultSet
      )

  readFullQuery(query: ESQuery): Promise<ESResultSet> ->
    this._find(query)

  read(query: ESQuery): Promise<ESResultSet> ->
    if query.ids:
      this.readIdQuery(query)
    else:
      this.readFullQuery(query)
