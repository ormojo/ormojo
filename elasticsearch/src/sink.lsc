import { AsyncSink, SinkResult, NotFoundError, DuplicateError } from '@ormojo/ormojo'
import { hydrateInstance, getBulkDataForInstance } from './instances'
import { VersionConflictError } from './errors'
// import { fixVersionConflicts } from './fixVersionConflicts'

errorForResult(res) ->
  err = if res.status == 404:
    new NotFoundError("not found")
  elif res.status == 409:
    if res.error?.type == "version_conflict_engine_exception":
      new VersionConflictError("version conflict")
    else:
      new DuplicateError("duplicate")
  else:
    new Error("unknown Elasticsearch error during write operation:" + JSON.stringify(res, 2))
  err.status = res.status
  err

// Unwrap elasticsearch item returned from bulk api
unwrapItem(item) ->
  for k in item:
    now item = item[k]
    break
  item

class ESSinkResult extends SinkResult:
  constructor() ->
    this.results = []
    this._err = null

  _pushResult(res, ignore404) ->
    if res.status >= 200 and res.status < 300:
      this.results.push(true)
    else if ignore404 and res.status == 404:
      this.results.push(false)
    else:
      err = errorForResult(res)
      if not this._err: this._err = err
      this.results.push(err)

  _lastResultWasSuccess() ->
    res = this.results
    if res.length > 0 and res[res.length - 1] == true: true else: false

  _recomputeErrorState(): void ->
    this._err = null
    for elem e in this.results:
      if e instanceof Error:
        this._err = e
        return

  _isVersionConflict() ->
    this._err = null
    let result = false
    for elem e in this.results:
      if e instanceof Error:
        if e.name == "VersionConflictError":
          now result = true
        else:
          if not this._err: this._err = e
          return false
    result

  firstError() -> this._err
  hasError() -> if this._err: true else: false

getBulkCreateOpForInstance(instance) ->
  id = instance._id or instance.id
  if id:
    {
      create: {
        _index: instance._index
        _id: id
      }
    }
  else:
    {
      index: {
        _index: instance._index
      }
    }

getBulkUpdateOpForInstance(instance, opts) ->
  {
    update: {
      _index: instance._index
      _id: instance._id
      ...if instance._occ and (not opts?.ignoreVersionConflicts): {
        if_seq_no: instance._occ.seq_no
        if_primary_term: instance._occ.primary_term
      }
    }
  }

getBulkUpsertOpForInstance(instance, opts) ->
  id = instance._id or instance.id
  {
    index: {
      _index: instance._index
      ...if id: { _id: id }
      ...if instance._occ and (not opts?.ignoreVersionConflicts): {
        if_seq_no: instance._occ.seq_no
        if_primary_term: instance._occ.primary_term
      }
    }
  }

getBulkCrupsertOpForInstance(instance, opts) ->
  if instance._isNewRecord:
    getBulkCreateOpForInstance(instance, opts)
  else:
    getBulkUpsertOpForInstance(instance, opts)

getBulkDeleteOpForInstance(instance) ->
  {
    delete: {
      _index: instance._index
      _id: instance._id or instance.id
    }
  }

bulkOperation(es, log, body, opts) ->
  rq = { body }
  if opts?.writeConcern != 'NONE': rq.refresh = 'wait_for'
  if opts?.refresh: rq.refresh = opts.refresh
  es.bulk(rq)

shouldThrowFirstError(data, opts) ->
  if opts?.throwFirstError == true:
    true
  else if opts?.throwFirstError == false:
    false
  else if data.length == 1:
    true
  else:
    false

crupsert(backend, log, data, lambda1, lambda2, opts) -/>
  esResult <- bulkOperation(
    backend.es
    log
    [...for elem datum in data:
      [ lambda1(datum, opts), lambda2(datum, opts) ]
    ]
    opts
  )

  result = new ESSinkResult()
  for idx i, elem item in esResult.items:
    unwrappedItem = unwrapItem(item)
    result._pushResult(unwrappedItem, false)
    if result._lastResultWasSuccess():
      hydrateInstance(data[i], unwrappedItem)

  // if opts?.fixVersionConflicts and result._isVersionConflict():
  //   now opts = Object.assign({}, opts, {
  //     _fixRecursion: (opts._fixRecursion or 0) + 1
  //     noTimestamp: true
  //   })
  //   if opts._fixRecursion <= (opts.maxFixRecursion or 1):
  //     <- fixVersionConflicts(backend, data, result, opts, opts?.isConflictFixable, opts?.fixConflict)

  if shouldThrowFirstError(data, opts) and result.hasError():
    throw result.firstError()

  result

export class ESSink extends AsyncSink:
  constructor(opts) ->
    super(opts)
    this.backend = opts.backend
    this.es = opts.es
    this.log = opts.log

  create(data, opts) ->
    crupsert(this.backend, this.log, data, getBulkCreateOpForInstance, getBulkDataForInstance, opts)

  update(data, opts) ->
    crupsert(this.backend, this.log, data, getBulkUpdateOpForInstance,
      (datum, opts) -> { doc: getBulkDataForInstance(datum, opts) }
      opts
    )

  upsert(data, opts) ->
    crupsert(this.backend, this.log, data, getBulkUpsertOpForInstance, getBulkDataForInstance, opts)

  crupsert(data, opts) ->
    crupsert(this.backend, this.log, data, getBulkCrupsertOpForInstance, getBulkDataForInstance, opts)

  delete(data, opts) ->
    bulkOperation(
      this.es, this.log
      [...for elem datum in data:
        [ getBulkDeleteOpForInstance(datum) ]
      ]
      opts
    ).then! (res) ->
      result = new ESSinkResult()
      for elem item in res.items:
        result._pushResult(unwrapItem(item), true)
      if shouldThrowFirstError(data, opts) and result.hasError():
        throw result.firstError()
      result
