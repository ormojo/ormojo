import { Query, Cursor, ResultSet } from '@ormojo/ormojo'
import { getIndexForType, getESTypeForType, toParentId } from './util'
import { createMemory as create, assignPlainObject } from '@ormojo/ephraim'

getArgsAsArray(args) ->
  if args and Array.isArray(args): args else: Array.prototype.slice.call(args)

_extend(obj) ->
  var args = Array.prototype.slice.call(arguments, 1);
  args.forEach(function(source) {
    if (source) {
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    }
  });
  return obj;

createNestedObject(base, names, value): void ->
  var lastName = arguments.length === 3 ? names.pop() : false;

  for (var i=0; i<names.length; i++) {
    if(Array.isArray(names[i])) {
      names[i] = names[i][0];
      base[names[i]] = base[names[i]] || [];
      now base = base[names[i]][base[names[i]].length] = Object.create(null);
    } else {
      now base = base[names[i]] = base[names[i]] || Object.create(null);
    }
  }

  if (lastName) {
    if (Array.isArray(lastName)) now value = [value];

    if (Array.isArray(value)) {
      base[lastName] = base[lastName] ? base[lastName].concat(value) : value;
    } else if (value instanceof Object) {
      base[lastName] ? _extend(base[lastName], value) : base[lastName] = value;
    }
    now base = base[lastName] = ((typeof base[lastName] === "object") ? base[lastName] : undefined) ||
          ((value === null || typeof value === "undefined") ? Object.create(null) : value);
  }

  if ((names.length == 0) && !lastName && value) {
    now base = value;
  }

export class ESQuery extends Query:
  constructor(backend) ->
    super(backend)
    this.body = Object.create(null)

  setType(T) ->
    super.setType(T)
    this.index = getIndexForType(T)
    this.type = getESTypeForType(T)
    this

  setParent(entOrId) ->
    this.parent = entOrId~toParentId!
    this

  setQueryDsl(body) ->
    this.body = body
    this

  q() ->
    args = getArgsAsArray(arguments)
    value = args.pop()
    createNestedObject(this.body, args, value)
    this

  setQuery(other) ->
    this.body = other.body
    this.limit = other.limit
    this.offset = other.offset
    this.index = other.index
    this.type = other.type
    this.ephraimType = other.ephraimType

  resumeFrom(cursor) ->
    this.setQuery(cursor.query)
    this.offset = cursor.offset
    this.limit = cursor.limit
    this

  // Get Elasticsearch Query DSL JSON for this query.
  getQueryDsl() ->
    this.body

export class ESCursor extends Cursor:
  constructor(query) ->
    super()
    this.query = query

  setFromOffset(offset, limit, total) ->
    this.offset = offset
    this.limit = limit
    this.total = total
    this

resolveType(typeMap, defaultType, errorOnMissingType, datum) ->
  idx = datum._index
  ty = datum._type
  if (not idx) or (not ty):
    if errorOnMissingType:
      throw new Error("could not map Elasticsearch result to Ephraim type")
    else:
      return defaultType
  T = typeMap(idx, ty)
  if not T:
    if errorOnMissingType:
      throw new Error("could not map Elasticsearch result to Ephraim type")
    else:
      return defaultType
  T


// Helper: Update an instance from an ES API return value.
// XXX: assign vs set...
export updateInstanceWithData(instance, esData) ->
  instance._isNewRecord = undefined
  if not esData: return instance

  // Data
  if esData._source:
    instance~assignPlainObject(esData._source)

  // Metadata
  if esData._id: instance.id = esData._id
  if esData._index: instance._index = esData._index
  if esData._version: instance._version = esData._version
  if esData._type: instance._type = esData._type
  if esData._score: instance._score = esData._score
  if esData._routing: instance._routing = esData._routing
  if esData._parent: instance._parent = esData._parent

  // XXX: clear delta here...
  //instance._clearChanges()
  instance

export class ESResultSet extends ResultSet:
  constructor(data, total, offset, originalQuery, maxScore = 0) ->
    super()
    this.maxScore = maxScore
    this.results = data or []
    this.total = total or this.results.length
    nextOffset = (offset or 0) + this.results.length
    if nextOffset < this.total:
      this.cursor = new ESCursor(originalQuery).setFromOffset(nextOffset, this.results.length, this.total)

  getTotalResultCount() -> this.total

  getCursor() -> this.cursor

  getMaxScore() -> this.maxScore

  _hydrate(typeMap, defaultType, errorOnMissingType) ->
    nextResults = [...for elem result in this.results:
      if result:
        T = resolveType(typeMap, defaultType, errorOnMissingType, result)
        if T:
          instance = T~create()
          [updateInstanceWithData(instance, result)]
      else:
        [undefined]
    ]
    this.results = nextResults
    this
