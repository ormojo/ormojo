import { esTypeMap } from './esTypeMap'
import { declaredFields } from '@ormojo/ephraim'
import { Timestamped } from '@ormojo/ormojo'

// Represents an index in Elasticsearch.
export class ESIndex:
  constructor(backend, name) ->
    this.backend = backend
    this.name = name
    this.types = {}
    this.properties = {}

  // Get the property descriptor for a single field
  getPropertyDescriptor(key, spec, fieldBinding = {}) ->
    // id and transient fields contribute no properties
    if key == 'id': return null
    if spec.transient: return null

    // Base configuration comes from Elasticsearch type map.
    // Can be overridden by the user mapping.
    typeProps = esTypeMap(spec.type)
    property = Object.assign({}, typeProps, fieldBinding.mapping)

    property

  getProperties(T, fields = {}) ->
    {...for key k, val spec in T~declaredFields():
      property = this.getPropertyDescriptor(k, spec, fields[k])
      if property: {[fields[k]?.key or spec.key]: property}
    }


  addEntityType(T, opts): void ->
    this.types[opts.type] = opts

    if opts.analyzer:
      this.analyzer = Object.assign(this.analyzer or {}, opts.analyzer)
    if opts.filter:
      this.filter = Object.assign(this.filter or {}, opts.filter)

    // XXX: Verify that incoming properties are compatible with existing ones
    Object.assign(this.properties, this.getProperties(T, opts.fields))

    // Add property for orm type mapping
    this.properties['orm_type'] = {
      "type": "keyword"
      "store": true
    }

    // For timestamped types, add @timestamp mapping
    if T.isKindOf(Timestamped):
      this.properties['@timestamp'] = { type: 'date', format: 'strict_date_optional_time||epoch_millis' }

    this.mappings = { properties: this.properties }

  _deleteIndex(): void ->
    this.backend.es.indices.delete({index: this.name})

// Represents the collection of indices associated with a backend.
export class ESIndices:
  constructor(backend) ->
    this.backend = backend
    this.typeMap = new Map()
    this.indices = {}
    this.prefixedIndices = {}

  addEntityType(T, opts): void ->
    // Compute index name from options data
    if not opts.index:
      throw new Error(`could not determine Elasticsearch index name for type '${T.name}'.`)
    if opts.indexPrefix:
      opts.index = opts.indexPrefix + opts.index

    // Verify type name
    if not opts.type:
      throw new Error(`could not determine Elasticsearch type name for type '${T.name}'`)

    let index = this.indices[opts.index]
    if not index:
      now index = new ESIndex(this.backend, opts.index)
      this.indices[opts.index] = index
    opts.indexRepresentation = index

    this.typeMap.set(T, opts)
    index.addEntityType(T, opts)

  getIndices() ->
    this.indices

  getTypeInfo(T) ->
    this.typeMap.get(T)

  findIndexByName(name) ->
    // Locate by name
    idx = this.prefixedIndices[name]
    if idx: return idx

    // Search by prefix
    for key k, val idx in this.indices:
      if name.startsWith(k):
        // TODO: allow index naming convention to be changed in config
        if (k == name) or (/_v(\d+)$/.test(name)):
          this.prefixedIndices[k] = idx
          return idx

    // Not found
    undefined

  getEphraimTypeForESType(esIndex, esType) ->
    idx = this.findIndexByName(esIndex)
    if idx:
      idx.types[esType].ephraimType
    else:
      this.backend.log.warn(`Unexpected type lookup failure for index '${esIndex}' and type '${esType}'`)
      undefined
